## 前提条件
* 有序数组
* 无重复元素
## 边界条件
分为两种左闭右闭[left, right]和左闭右开[left, right]
### 左闭右闭
* 此时循环条件可以是`while(left <= right)`，因为左等于右的区间也存在
* 改变条件`left = mid + 1`,`right = mid - 1`。因为左右都涵盖在内，这次的middle一定不是target。
#### 示例写法
```C++
int binarySearch(vector<int>& nums, int target) {
	int left = 0;
	int right = nums.size() - 1;
	while (left <= right) {
		int mid = left + (right - left) / 2;
		if (nums[mid] == target) return mid;
		else if (nums[mid] < target) left = mid + 1;
		else if (nums[mid] > target) right = mid - 1;
	}
	return -1;
}
```
### 左闭右开
* 此时循坏条件是`while(left < right)`因为当`left == right`这样的区间是没有意义的。
* 改变条件`right = mid`
#### 示例写法
```C++
int binarySearch(vector<int>& nums, int target) {
	int left = 0;
	int right = nums.size() - 1;
	while (left < right) {
		int mid = left + (right - left) / 2;
		if (nums[mid] == target) return mid;
		else if (nums[mid] < target) left = mid + 1;
		else if (nums[mid] > target) right = mid;
	}
	return -1;
}
```
## 力扣题目
* 704. 二分查找
* [35.搜索插入位置](https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html)：有点问题
* [34.在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html)：不太会做。
			*  寻找target在数组中出现的第一个位置和最后一个位置
			*  ***重点 ： 需要多做几遍***
* 69.x 的平方根 
- 367.有效的完全平方数
-----
## Tips
只要是有序数组都可以考虑二分法。