链表在内存中不是连续分布的。
链表的增添和删除操作时间复杂度都是O（1），但是需要从头节点进行查找，查找的时间复杂度是O（n）。
链表有时可以设计一个虚拟头节点（不带数据），这样所有点删除等操作一样方便。但有时候就不需要加，加上会出错([面试题 02.07. 链表相交 - 力扣（Leetcode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/))

头节点指针Head是不能改变的，当遍历链表的时候定义一个临时指针cur进行遍历。
删除节点后记得delete。
# 创建链表
- 头插法：插入元素顺序与实际顺序相反，可以用于翻转链表
- 尾插法
```c++

```
# 链表翻转
- 双指针法
```c++
ListNode* reverseList(ListNode* head) {
	ListNode* cur = head;
	ListNode* tmp;
	ListNode* pre = NULL;
	while (cur) {
		tmp = cur->next;
		cur->next = pre;

		pre = cur;
		cur = tmp;
	}
	return pre;
}
```
- 递归法
- 头插法
```c++
ListNode* reverseList(ListNode* head) {
	ListNode* dummyHead = new ListNode(0);
	ListNode* cur1 = head;
	ListNode* tmp;
	// ListNode* cur2 = dummyHead;
	whlile (cur1 != null) {
		tmp = cur;
		tmp->next = dummyHead->next;
		dummyHead->next = tmp;
		cur1 = cur1->next;
	}
}
```
- 使用栈来翻转

# 经典题目
1. 创建链表
2. 翻转链表
3. 链表是否有环，入口在哪？
4. 删除倒数第n个节点
5. 链表相交
6. 两两交换链表节点