来自小林coding：文件系统和网络系统
[9.1 什么是零拷贝？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/os/8_network_system/zero_copy.html#%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0)

-----
# 组成
linux一切皆文件，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。

Linux 文件系统会为每个文件分配两个数据结构：**索引节点（_index node_）和==目录项（_directory entry_）==**，它们主要用来记录文件的元信息和目录层次结构。

- ==索引节点==，也就是 _inode_，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、**数据在磁盘的位置**等等。索引节点是文件的**唯一**标识，它们之间一一对应，也同样都会被存储在硬盘中，所以**索引节点同样占用磁盘空间**。
- ==目录项==，也就是 _dentry_，用来记录文件的名字、**索引节点指针**以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，**目录项是由内核维护的一个数据结构，不存放于磁盘，而是==缓存在内存==**。

由于索引节点唯一标识一个文件，而目录项记录着文件的名字，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别名。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。
目录也是文件。

>目录与目录项

不是一个东西。
目录是文件，持久化存储在硬盘。**目录项是内核一个数据结构，缓存在内存。**
如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。
注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。

>文件在磁盘的存储

物理上使用chs表示唯一**扇区**，512B.
逻辑上文件系统把多个扇区组成一个**逻辑块**，每次读写的单位就是逻辑块。LINUX中逻辑块大小为4KB。

>索引节点、目录项、文件数据关系

![](Pasted%20image%2020230705205806.png)
**磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。**

- _超级块_，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。
- _索引节点区_，用来存储索引节点；
- _数据块区_，用来存储文件或目录数据；

不可能把超级块和索引节点区全部加载到内存，只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：

- 超级块：当文件系统挂载时进入内存；
- 索引节点区：**当文件被访问时**进入内存；

# VFS

虚拟文件系统
文件系统的种类众多，而操作系统希望**对用户提供一个统一的接口**，于是在用户层与文件系统层引入了中间层，这个中间层就称为**虚拟文件系统（_Virtual File System，VFS_）。**
VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。
![你好](Pasted%20image%2020230705210128.png)

## 统一文件模型

VFS的核心设计——统一文件模型。
Unix家族的VFS的文件模型定义了四种对象，这四种对象构建起了统一文件模型：
- superblock：存储文件系统基本的元数据。如文件系统类型、大小、状态，以及其他元数据相关的信息（元元数据）
- inode：保存一个文件相关的元数据。包括文件的所有者（用户、组）、访问时间、文件类型等，但不包括这个文件的名称。文件和目录均有具体的inode对应。
- directory entry（dentry）：保存了文件（目录）名称和具体的inode的对应关系，用来粘合二者，同时可以实现目录与其包含的文件之间的映射关系。另外也作为缓存的对象，缓存最近最常访问的文件或目录，提示系统性能。

# 文件系统分类

==按照存储位置分：==
- _**磁盘的文件系统**_，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。
- _**内存的文件系统**_，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 `/proc` 和 `/sys` 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。
- _**网络的文件系统**_，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。

文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。

# 文件的使用

![](Pasted%20image%2020230705211655.png)

## 文件描述符表

打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪就是操作系统**为每个进程维护一个文件描述符表**，文件表里的每一项代表「**文件描述符**」。只有打开文件才有文件描述符。不同的文件描述符也会指向同一个文件。整个系统维护一张打开文件表。
POSIX标准要求每次打开文件时（含socket）必须使用当前进程中最小可用的文件描述符号码
![](Pasted%20image%2020230705212102.png)

内核维护的3个数据结构：
  1. 进程级的文件描述符表
  2. 系统级的打开文件描述符表
  3. 文件系统的i-node表
![](Pasted%20image%2020230705212530.png)

在用户视角里，文件就是一个持久化的数据结构，但操作系统并不会关心你想存在磁盘上的任何的数据结构，操作系统的视角是如何把文件数据和磁盘块对应起来。
所以，用户和操作系统对文件的读写操作是有差异的，**用户习惯以字节的方式读写文件，而操作系统则是以数据块来读写文件，那屏蔽掉这种差异的工作就是文件系统了。**

**文件系统的基本操作单位是数据块**。

# 文件的存储

- 连续空间存放方式：起始块+长度
- 非连续空间存放方式
非连续空间存放方式又可以分为「链表方式」和「索引方式」。
链表可分为「**隐式链表**」和「**显式链接**」两种形式。

显式链接用到了**内存**中的这样一个表格称为**文件分配表（_File Allocation Table，FAT_）**。


索引的实现是为每个文件创建一个「**索引数据块**」，里面存放的是**指向文件数据块的指针列表**，**文件头需要包含指向「索引数据块」的指针**。说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。
![](Pasted%20image%2020230705215402.png)


链表 + 索引的组合，这种组合称为「**链式索引块**」，它的实现方式是**在索引数据块留出一个存放下一个索引数据块的指针**，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。
![](Pasted%20image%2020230705215451.png)

还有另外一种组合方式是索引 + 索引的方式，这种组合称为「**多级索引块**」，实现方式是**通过一个索引块来存放多个索引数据块**，一层套一层索引
![](Pasted%20image%2020230705215512.png)

## 比较

![](Pasted%20image%2020230705215529.png)

## UNIX实现

![](Pasted%20image%2020230705215659.png)

# 空闲空间管理

- 空闲表法
- 空闲链表法
- 位图法

## 空闲表法

适用于连续分配
![](Pasted%20image%2020230705215806.png)

## 空闲链表法

每一个空闲块里有一个指针指向下一个空闲块
![](Pasted%20image%2020230705215916.png)

## 位图法

位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。

在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。
即**用于数据块区和索引节点区**。

 Linux 是用位图的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配

# 文件系统的结构

「一个块的位图 + 一系列的块」，「一个块的 inode 的位图 + 一系列的 inode 的结构」
在 Linux 文件系统，把这个结构称为一个**块组**，那么有 N 多的块组，就能够表示 N 大的文件。

下图给出了 **Linux Ext2 整个文件系统的结构和块组**的内容，**文件系统都由大量块组组成**，在硬盘上相继排布：
![](Pasted%20image%2020230705220442.png)
- _超级块_，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。
- _块组描述符_，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。
- _数据位图和 inode 位图_， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。
- _inode 列表_，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。
- _数据块_，包含文件的有用数据。

# 目录的存储

**普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。** 
在目录文件的块中，最简单的保存格式就是**列表**，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。
为提高查找效率，保存目录的格式改为**哈希表**。
![](Pasted%20image%2020230705220756.png)

# 文件I/O

![](Pasted%20image%2020230706140020.png)

## 缓冲/非缓冲IO(用户态标准库缓冲)

文件操作的标准库是可以实现数据的缓存，那么**根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O**：

- 缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。
- 非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。

**这里所说的「缓冲」特指标准库内部实现的缓冲。**

>目的：减少系统调用的次数，毕竟系统调用有CPU上下文切换开销
>举例：c++使用endl换行时才刷新标准库缓冲，真正输出

一般可以使用flush、换行刷标准库缓存

## 直接/非直接IO（内核态page cache）

>目的：Linux为了减少磁盘IO的次数（太慢）、

在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「_页缓存（page cache）_」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。page cache中的内容程序崩溃不会丢失。

**根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O**：
- 直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。
- 非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。

`O_DIRECT` 标志表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。

> 非直接 I/O （page cache）内核什么情况下才会把缓存数据写入到磁盘？

以下几种场景会触发内核缓存的数据写入磁盘：

- 在调用 `write` 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；
- 用户主动调用 `sync`，内核缓存会刷到磁盘上；
- 当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；
- 内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；

>pagecache的作用

- 利用时间局部性缓存数据
- 利用空间局部新预读数据

## 阻塞/非阻塞IO      VS    同步/异步IO

分辨两个过程：**「内核数据准备好」和「数据从内核态拷贝到用户态」**
阻塞IO等待这两个过程。

![](Pasted%20image%2020230706002413.png)

非阻塞IO，不阻塞再内核数据准备好（而是轮询），阻塞在从内核拷贝数据到用户态过程。
如果 socket 设置了 `O_NONBLOCK` 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O。
![](Pasted%20image%2020230706002536.png)
注意，**这里最后一次 read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。**

为了解决这种傻乎乎轮询方式，于是 **I/O 多路复用**技术就出来了，如 select、poll，它是通过 I/O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。

下图是使用 select I/O 多路复用过程。注意，`read` 获取数据的过程（数据从内核态拷贝到用户态的过程），也是一个**同步的过程**，需要等待：
![](Pasted%20image%2020230706002725.png)
第一步不再轮询，但是read仍需等待。


无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用**都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。**

而==真正的**异步 I/O** 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。==
![](Pasted%20image%2020230706002928.png)

I/O 是分为两个过程的：

1. 数据准备的过程
2. 数据从内核空间拷贝到用户进程缓冲区的过程

阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。

异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。

异步IO只能使用直接IO，即不通过PageCache。
![](Pasted%20image%2020230719153956.png)

## 文件传输

根据小林coding内容：

- 小文件传输采用**零拷贝（sendfile + SG-DMA）**，kafka和nginx都是用了零拷贝技术。
- 大文件传输采用**异步IO + 直接IO**