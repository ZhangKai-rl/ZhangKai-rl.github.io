# 协议

## 网络层协议

### ICMP

ICMP基于IP协议。
分为查询报文（ping）和差错报文（traceroute）

## 应用层协议

### SSL/TLS

安全套接层协议和传输层安全协议。
是一个安全通信框架，上面可以承载HTTP协议或者SMTP/POP3协议等。因而他的位置可能位于传输层和应用层之间。

### HTTP/HTTPS

超文本传输协议。
TCP是基于字节流的（二进制串），因而没有任何边界，出现粘包问题（解决粘包问题的四种方法：定长、标记、包头+包体、应用层协议分包，muduo使用第三种）。
TCP是全双工的，被HTTP/1.1用成了半双工。

#### 优缺点（HTTP/1.1）

优点 ：
- 简单：header + body，kv形式
- 灵活可扩展
- 跨平台

缺点：
- 无状态：可以使用cookie
- 不安全：明文传输+不验证身份+无法证明报文完整
- 解决了请求队头阻塞，但是没有解决相应对头阻塞

#### 改进

##### HTTPS

主要是解决了不安全的问题。
HTTP**S** 在 HTTP 与 TCP 层之间加入了 `SSL/TLS` 协议。
- 信息加密不再明文传输
- 身份证书验证身份：数字证书
- 校验机制验证报文完整性：摘要算法+数字签名


### RPC

远程过程调用，本质是一种调用方式，像 gRPC 和 Thrift 这样的具体实现，才是协议。
可以基于TCP/UDP或者HTTP。像调用本地方法一样调用远程方法，屏蔽了网络细节。比较出名的：bRPC, gRPC, thrift

>有了http，为什么还要有rpc

RPC比HTTP出现时间更早。C/S架构大多用的rpc，B/S架构需要同意标准，出现了HTTP。

- **服务发现**：服务发现的意思是找到服务对应的IP和端口的过程。HTTP使用DNS获取IP。RPC使用专门的中间服务保存，也可以基于DNS。
- **底层连接形式**：HTTP/1.1默认在建立底层 TCP 连接之后会一直保持这个连接（**Keep Alive**），之后的请求和响应都会复用这条连接；而 **RPC** 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个**连接池**
- **传输内容**：基于TCP传输的消息都分为Header和Body。body都是二进制01串，HTTP结构体使用Json序列化成二进制01串，RPC使用Protobuf。HTTP头部比较冗余，RPC定制化程度更高，因而性能更好。

### WebSocket协议

和socket完全没有关系。
解决如网页游戏这种，服务器给浏览器法消息这种问题。完美继承了TCP的全双工能力，也解决了TCP粘包问题。

### DNS协议

根据域名找对应的IP地址。
有两种方式：递归查询和迭代查询。
DNS服务器从高到低分为：
- 根 DNS 服务器（.）
- 顶级域 DNS 服务器（.com）
- 权威 DNS 服务器（server.com）
- 本地DNS服务器（host文件）
![](Pasted%20image%2020230730163014.png)
上图为迭代查询

## 传输层

### TCP协议

![](Pasted%20image%2020230730163423.png)
TCP报头，**报头中的window指的是swnd**，用于端到端（发送方和接收方协调）的滑动窗口（TCP缓存）和流量控制。
**TCP数据包的数据即为HTTP报文。**
是端到端的协议，因而协议头中要有端口号（既然是端到端协议，那么肯定属于点到点协议，IP地址在下层IP协议头部）


TIME_WAIT状态持续2MSL原因：
- 防止发给服务端的ACK丢失
- 使本链接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

#### 复位报文段

产生复位报文段的三种情况：
- 访问不存在的端口（或者端口被TIME_WAIT连接占用）
- 异常终止连接
- 客户端如果向半打开连接写数据，对方将回应复位报文段RST。

#### TCP问题

>如何判断是否出现网络拥塞

正常来说网络负载增加，网络吞吐量也应该增加。如果网络吞吐量随着网络负责的增大反而下降，那么网络可能进入了拥塞状态。（命令：iptraf）

TCP拥塞控制的判断方法：
- 出现丢包
- 拥塞窗口（cwnd）较小
- ACK延迟 / 重复确认

>如何保证到达顺序

>怎么保证可靠

#### TCP进阶
##### keepalive属性
[linux下TCP keepalive 属性设置_linux上面的tcpkeepalive_sunxiaopengsun的博客-CSDN博客](https://blog.csdn.net/sunxiaopengsun/article/details/56842748#:~:text=tcp%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%9C%89%E4%B8%AAkeepalive%E7%9A%84%E5%B1%9E%E6%80%A7%2C%E5%8F%AF%E4%BB%A5%E4%B8%BB%E5%8A%A8%E6%8E%A2%E6%B5%8Bsocket%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8%2C%E4%B8%8D%E8%BF%87%E8%BF%99%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%BE%88%E5%A4%A7.%20%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE%E5%8F%AF%E6%9B%B4%E6%94%B9%2Fetc%2Fsysctl.conf%2C%E5%8A%A0%E4%B8%8A%3A%20net.ipv4.tcp_keepalive_intvl%20%3D%2020,net.ipv4.tcp_keepalive_probes%20%3D%203%20net.ipv4.tcp_keepalive_time%20%3D%2060)
tcp实际应用中会检测连接是否可用，不可用可分为：
1. 对端正常关闭
2. 对端非正常关闭：断电、崩溃、断网。此时无法通知另一端，连接会一直存在
对于第二种，tcp会使用keepalive属性，主动探测socket是否可用。
可以使用`setsockopt`进行keepalive属性设置，可以设置：是否开启keepalive属性、何时进行探测、探测发包间隔、探测未收到响应时的探测次数。
在程序中会表现为：当tcp检测到对端socket不再可用时(不能发出探测包,或探测包没有收到ACK的响应包),select会返回socket可读,并且在recv时返回-1,同时置上errno为ETIMEDOUT。
## 网络层

### IP协议

路由表中的条目目标地址和子网掩码都是 `0.0.0.0`，这表示**默认网关**，如果其他所有条目都无法匹配，就会自动匹配这一行。
源IP和目标IP是不会变的。

### ARP协议

根据IP地址找到对应的MAC地址。因为既有mac也有ip，所以也可以说是网络层协议。
ARP缓存：为了不每次都在网络中广播找MAC，会维持一个ARP缓存。

## 数据链路层

MAC地址为48位。
这一层发送的是帧。如果目标不是本网络中的那么目标MAC为路由器MAC地址。

==转发的过程中，源 IP 地址和目标 IP 地址是不会变的（前提：没有使用 NAT 网络的），源 MAC 地址和目标 MAC 地址是会变化的。==

# 未分类知识

> 关于各个报文

- `MTU`：是数据链路层的概念。以太网最大帧长为1500字节。
- `MSS`：传输层概念。除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

![](Pasted%20image%2020230730163957.png)