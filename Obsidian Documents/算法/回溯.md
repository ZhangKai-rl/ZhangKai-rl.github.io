回溯是递归的副产品，有递归就会有回溯。
==回溯法都可以抽象为树形结构==（N叉树）
# 如何理解回溯法

**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！
因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。
递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。
# 回溯法模板

回溯三部曲：
- 回溯法的返回值和参数
`void backtracking(vector<int>& nums, vector<int>& path, vector<vector<int>> res)`
一般只需要数组和当前遍历到的数组的索引。有的题还需要其他参数。path收割当前符合条件的路径，res收集最终结果，这俩个参数也可以定义为Solution的成员变量。
- ==确定中止条件==
一般来说是到达叶子节点终止。一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
```c++
if (终止条件) {
	存放结果；
	return ；
}
```
- 回溯的遍历过程
回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
![](Pasted%20image%2020230307150455.png)
```c++
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```
**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。
## 总体框架

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

# 子集问题

抽象成树形结构后，每个结点都是要收获的结果。
# 分割问题

# 组合问题

# 关于去重

在数组中有重复元素时要进行去重操作，除去相同的子集/组合。
# 排列问题

## 回溯三部曲

- 终止条件
全排列如果path长度和原数组长度相同说明找到一个可行的排列。

## 全排列且数组中有重复元素


首先是全排列，使用一个used数组表示这个元素被访问过（定义为数组大小，初始化为false），每层的逻辑都从0开始而不是从start开始来实现排列。这样实现了树枝上可以重复。一个排列不能使用同一个元素两次（同一个不是重复），每次都从0开始建立排列。
但是在树层上不能有元素。那么在每层的逻辑前面定义一个set如果已经在set里面出现过那么就跳过这层的这个元素。continue，去这一层的下一个元素。

# 去重

去重包括树枝去重和树层去重

