# 分类

![](Pasted%20image%2020231031010648.png)
单源正权图中，根据稀疏或者稠密图选择朴素还是堆优化Dijkstra。
稠密图和稀疏图：m和n^2一个级别为稠密图，即边很多。
无向图是特殊有向图：每次存两条边即可

# 难点

不会考察证明算法，而是考察建图，如何将问题抽象成最短路问题。因此学习时侧重中于实现、抽象而非原理。
# 实现
## 朴素Dijkstra

> 基本特点

适用场景：==稠密图（邻接矩阵存）==、有向图（无向图可以存两条边转化为有向图）
简介：单源最短路径算法，有点类似动态规划，每次循环确定一个点的最短距离（t点，dijk原理证明百度）
时间复杂度：n^2
空间复杂度：

> 需要的额外空间：

- dist数组，下标为点id。`dist[source] = 0, dist[others] = 0x3f3f3f3f`，可以使用`memset(dist, 0x3f, sizeof dist)`来初始化
- 图邻接矩阵存储数组gNN; 有向图的话值就是边的权重
- st[N]是否访问过（确定最短路径）

> 算法步骤

1. 初始化dist数组， 初始化源点dist
2. 进入循环，循环n次（第一次一定是源点）
	- 每次找未遍历过的最近的点t，加入已遍历的集合s
	- 遍历这个点的所有*出边*，进行比较更新，即判断`dist[x]和dist[t] + w`的大小，进行**松弛操作**
### 模板

模板题：[849. Dijkstra求最短路 I - AcWing题库](https://www.acwing.com/problem/content/851/)

注意事项：
- 本题自环和重边的处理
- 点编号从1开始
- 判断是稠密图还是稀疏图，从而选择具体的存储方式。

```cpp
int g[N][N], dist[N];
bool st[N];

int dijkstra() {
	memst(dist, 0x3f,sizeof dist);
	dist[1] = 0;
	for (int i = 1; i <= n; i ++) {
		int t = -1;
		for (int j = 1; j <= n; j ++) {
			if (!st[j] && (t == -1 || dist[t] > dist[j]))
				t = j;
		}
		st[t] = true;
		for (int j = 1; j <= n; j ++) {
			dist[j] = min(dist[j], dist[t] + g[t][j]);
		}
	}
	if (dist[n] == 0x3f3f3f3f) return -1;
	return dist[n];
}

int main() {
	cin >> n >> m;
	memset(g, 0x3f, sizeof g);
	while (m --) {
		int x, y, z;
		cin >> x >> y >> z;
		g[x][y] = min(g[x][y], z);
	}

	cout << dijkstra() << endl;
}
```
## 堆优化Dijkstra

堆的选择有两种：
- 手写堆（负责版本），可以实现堆中无冗余
- stl优先队列，堆中会有==冗余==。***

适用场景：稀疏图因而要使用邻接表存储图。

>需要的额外空间

- 邻接表，模拟版，包括idx，e[N], ne[N], w[N], h[N];
- priority_queue
- dist[N]
- st[N]

### 模板

模板题：[850. Dijkstra求最短路 II - AcWing题库](https://www.acwing.com/problem/content/852/)
> 注意问题

- 如何建立优先队列小根堆
- h的初始化, dist的初始化
- 因为n和m是同一数量级，因而是稀疏图采用邻接表存储结构。
```cpp
typedef pair<int, int> PII;

int n, m;

int idx, e[N], ne[N], w[N], he[N];
int dist[N];
bool st[N];

void add(int a, int b, int c) {
	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

int dijkstra() {
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	priority_queue<PII, vector<PII>, greater<PII>) heap;
	heap.push({0, 1});

	while (heap.size()) {
		auto t = heap.top();
		heap.pop();
		int vertex = t.second, distance = t.first;
		if (st[vertex]) continue;
		st[vertex] = true;

		for (int i = h[vertex]; i != -1; i = ne[i]) {
			int j = e[i];
			dist[j] = min(dist[j], dist[vetex] + w[j]);
			heap.push({dist[j], j});
		}
	}

	if (dist[n] == 0x3f3f3f3f) return -1;
	return dist[n];
}

int main() {
	cin >> n >> m;
	memset(h, -1, sizeof h);
	while (m --) {
		int a, b, c;
		cin >> a >> b >> c;
		add(a, b, c);
	}
	cout << dijkstra() << endl;
}
```
## Bellman-Ford
### 基础

> 适用场景

**负权**边。负权回路时最短路径不一定存在（每次转一圈减少一定距离，限制路径长度时无所谓了）。找负环。**限制路径长度。**
![](Pasted%20image%2020231104223329.png)

> 基本思想

迭代n次，每次循环所有边a,b,w进行松弛操作。
![](Pasted%20image%2020231104222530.png)
原理可以证明满足：dist[b] <= dist[a] + w(三角不等式)。
最外层迭代次数的含义：从1号点走不超过k条边的最短路的距离。可以推出如果第k次进行了更新，表示存在一条经过k条边的最短路径。**根据这个原理可以找负环。**

> 额外空间

- 存边的方式可以使用结构体。
- dist[N]， last[N]， edges[M]

> 复杂度

- 时间复杂度：O(nm)
### 模板

模板题：[853. 有边数限制的最短路 - AcWing题库](https://www.acwing.com/problem/content/855/)

>注意问题

- 负权，路径限制，负权回路
- 边的存储，Bellman-Ford使用结构体数组存储边
- 路径长度限制时防止串联，注意松弛操作时使用lastdist
- 最后判断是否能到达的方式
```cpp
#include <iostream>
#include <cstring>

const int N = 510, M = 10010;

struct Edge{
    int a, b, w;
}edges[M];

int n, m, k;
int dist[N], last[N];

void bellman_ford() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    for (int i = 0; i < k; i ++) {
        memcpy(last, dist, sizeof dist);
        for (int j = 0; j < m; j ++) {
            auto e = edges[j];
            dist[e.b] = std::min(dist[e.b], last[e.a] + e.w);
        }
    }
}

int main() {
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 0; i < m; i ++) {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        edges[i] = {x, y, z};
    }
    
    bellman_ford();
    
    if (dist[n] > 0x3f3f3f3f / 2) puts("impossible");
    else printf("%d", dist[n]);
}
```
## SPFA

> 算法思想

**是对bellman_ford算法做一个优化**，针对松弛操作，每次将变化过的放进队列，然后更新他的出边，不再暴力循环所有边。只有dist[a]变小，dist[b]才会变小，使用宽搜队列进行优化。队列里面存变小的节点。类似Dijkstra算法。

>存储空间

- st数组，表示当前点是否再队列中
- SPFA一般使用邻接表存储
- dist数组，cnt数组表示到1点到该点最短路的长度，用于判断环

>复杂度

- 时间复杂度：O(m)，最坏O（nm）

> 适用场景

不含负环。很多正权图也可以使用SPFA。效率高于Dijkstra。
**一般使用spfa判断负环**，判断负环的原理都是抽屉原理，使用`cnt[x] >= n`来判断。至少n条边，那么这条路径就有至少n+1个点，一定有负环。
### 模板

模板题：[851. spfa求最短路 - AcWing题库](https://www.acwing.com/problem/content/853/)
[852. spfa判断负环 - AcWing题库](https://www.acwing.com/problem/content/854/)
```cpp
#include <iostream>
#include <cstring>
#include <queue>

const int N = 100010;

int n, m;
int h[N], idx, e[N], ne[N], w[N];
int dist[N];
bool st[N];

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

int spfa() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    std::queue<int> q;
    q.push(1);
    st[1] = true;
    
    while (q.size()) {
        auto t = q.front();
        q.pop();
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]) {
            int vertex = e[i];
            if (dist[vertex] > dist[t] + w[i]) {
                dist[vertex] = dist[t] + w[i];
                if (!st[vertex]) {
                    q.push(vertex);
                    st[vertex] = true;
                }
            }
        }
    }
    
    return dist[n];
}

int main() {
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    while (m --) {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        add (x, y, z);
    }
    
    auto ans = spfa();
    
    if (ans == 0x3f3f3f3f) puts("impossible");
    else printf("%d\n", ans);
}
```

```cpp
#include <iostream>
#include <queue>
#include <cstring>

const int N = 2010;
const int M = 10010;

int n, m;
int h[N], idx, e[M], ne[M], w[M];
int dist[N], cnt[N];
bool st[N];

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

bool spfa() {
    std::queue<int> q;
    for (int i = 1; i <= n; i ++) {
        st[i] = true;
        q.push(i);
    }
    
    while (q.size()) {
        int t = q.front();
        q.pop();
        st[t] = false;
        
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                
                if (cnt[j] >= n) return true;
                if (!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return false;
}

int main() {
    scanf("%d%d", &n, &m);
    
    memset(h, -1, sizeof h);
    
    while (m --) {
        int x,y,z;
        scanf("%d%d%d", &x, &y, &z);
        add(x,y,z);
    }
    
    if (spfa()) puts("Yes");
    else puts("No");
}
```
## Floyd

多源汇最短路径。
一般为稠密图。直接使用边来表示最短路径即可

### 模板

模板题：[854. Floyd求最短路 - AcWing题库](https://www.acwing.com/problem/content/description/856/)

```cpp
#include <iostream>
#include <cstring>

const int N = 210;
const int INF = 1e9;

int n, m, k;
int d[N][N];

void floyd() {
    for (int k = 1; k <= n; k ++) {
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= n; j ++) {
                d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }
}

int main() {
    scanf("%d%d%d", &n, &m, &k);
    
    for (int i = 1; i <= n;i ++){
        for (int j = 1; j <= n; j ++) {
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;
        }
    }
    while (m --) {
        int x,y,z;
        scanf("%d%d%d", &x, &y, &z);
        d[x][y] = std::min(d[x][y], z);
    }
    
    floyd();
    
    while (k --) {
        int a, b;
        scanf("%d%d", &a, &b);
        
        if (d[a][b] > 0x3f3f3f3f / 2) puts("impossible");
        else printf("%d\n", d[a][b]);
    }
    
    return 0;
}
```