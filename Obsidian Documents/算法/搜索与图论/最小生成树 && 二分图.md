![](Pasted%20image%2020231106193543.png)
# 最小生成树

一般是无向图求最小生成树。
稠密图使用朴素Prim，稀疏图使用Kruskal。堆优化版Prim基本不用（不讲）。
Prim类似于Dijkstra，也分两种。
## 朴素Prim

算法思想非常类似朴素Dijkstra。因而同样适用于**稠密图**，使用邻接矩阵存储边。
Dijkstra算法思想：初始化距离；进行n次循环；每次寻找未曾遍历过的(不在集合中的)最短的边，然后根据这条边进行松弛操作更新所有出边到==起点1（Prim是到集合）==的距离。

需要选n个点，需要迭代n次
因为肯定没环，所有权正负都可以。 

> 注意点
- dist[t]的含义：表示t点到集合的距离。
- st[t]：是否已经加入集合
- 松弛操作，要先加入集合再松弛防止自环问题

>算法步骤
- 初始化dist数组
- 进行n次迭代
	- 找距离最近的点
	- 更新res权值；加入集合；判断是否连通
	- 进行松弛操作
### 模板

模板题：[858. Prim算法求最小生成树 - AcWing题库](https://www.acwing.com/problem/content/860/)
>注意事项

- 边存储方式
- 重边的处理：初始化+ min
- 无向图的存储
```cpp
#include <iostream>
#include <cstring>

const int N = 510;
const int INF = 0x3f3f3f3f;

int n, m;
int g[N][N];
int dist[N];
bool st[N];

int prim() {
    memset(dist, 0x3f, sizeof dist);
    
    int res = 0;
    for (int i = 0; i < n; i ++) {
        int t = -1;
        for (int j = 1; j <= n; j ++)
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        
        if (i && dist[t] == INF) return INF;
        if (i) res += dist[t];
        st[t] = true;
        
        for (int j = 1; j <= n; j ++) dist[j] = std::min(dist[j], g[t][j]);
    }
    return res;
}

int main() {
    scanf ("%d%d", &n, &m);
    memset(g, 0x3f, sizeof g); 
    
    while (m --) {
        int u,v,w;
        scanf("%d%d%d", &u,&v,&w);
        g[u][v] = g[v][u] = std::min(g[u][v], w);
    }
    
    auto t = prim();
    if (t == INF) puts("impossible");
    else printf("%d\n", t);
    
    return 0;
}
```
## Kruskal

算法思路和代码比Prim简单很多。
>适用场景

最小生成树，稠密图。

>算法步骤
1. 将所有边按照权值排序（最耗时的一步mlogm)
2. 枚举每条边a-b，w=c；如果ab不连通，将边加入集合中（并查集实现）O（1*m)

> 存储

- 边使用结构体存方便排序
- 并查集p数组
### 模板

>注意问题
- 数组如何使用sort排序
- 存储
- cnt < n - 1
```cpp
#include <iostream>
#include <algorithm>

const int N = 100010, M = 2e5 + 10;
const int INF = 0x3f3f3f3f;

int n, m;
int p[N];

struct Edge {
    int a, b, w;
    
    bool operator<(const Edge& edge) const {
        return w < edge.w;
    }
}edges[M];

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal() {
    std::sort(edges, edges + m);
    
    int ans = 0, cnt = 0;
    for (int i = 0; i < m; i ++) {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        if (a != b) {
            p[a] = b;
            cnt ++;
            ans += w;
        }
    }
    
    if (cnt < n - 1) return INF;
    return ans;
}

int main() {
    scanf("%d%d", &n, &m);
    
    for (int i = 0; i < m; i ++) {
        int a,b,w;
        scanf("%d%d%d", &a,&b,&w);
        edges[i] = {a,b,w};
    }
    
    for (int i = 1; i <= n; i ++) p[i] = i;
    
    auto t = kruskal();
    
    if (t == INF) puts("impossible");
    else printf("%d\n", t);
    
    return 0;
}
```
# 二分图

两个重要问题：
- 如何判断是不是二分图
- 匈牙利算法求二分图最大匹配

> 什么是二分图

两个集合，两个集合间有边连接，每个集合中的点之间没有边。

>什么是二分图的最大匹配

给出一个二分图，要求一个点只能跟一个边进行连接。
yxc比喻：将两个集合分别类比为男、女，边类比为好感度，能凑成的最大对数即为二分图最大匹配。
二分图中任意两条边都没有公共端点的边的集合被称为图的一组匹配。
## 染色法

原理：一张图是二分图，当且仅当图中没有奇数环。
当一个节点被标记成颜色1后，所有相邻节点要标记成颜色2，如果标记过程产生颜色冲突，那么
实现：具体实现方式有dfs，bfs两种，一般使用dfs

>存储空间

- color[N]：即代表结点的颜色，也表示是否染色过。
- 图存储方式：邻接表

>DFS

- 返回类型：bool，表示是否是二分图。
- 参数为点和该点应该染的颜色。
- 染色当前点，遍历出边进行递归染其他色
### 模板

模板题：[860. 染色法判定二分图 - AcWing题库](https://www.acwing.com/problem/content/862/)

>注意问题：

- 无向图邻接表存储要add两次
- `h[N], e[M], ne[M], w[M]` 
- `memset(h, -1, sizeof h)`
- 顶点编号是`[1, n]`

```cpp
#include <iostream>
#include <cstring>

const int N = 100010, M = 200010;

int n, m;
int h[N], idx, e[M], ne[M];
int color[N];

int add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

bool dfs(int x, int c) {
    color[x] = c;
    
    for (int i = h[x]; i != -1; i = ne[i]) {
        int j = e[i];
        
        if (!color[j]) {
            if (!dfs(j, 3-c))
                return false;
        }
        else if (color[j] == c) return false;
    }
    return true;
}

int main() {
    memset(h, -1, sizeof h);
    
    scanf("%d%d", &n, &m);
    while (m --) {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }
    
    int flag = false;
    for (int i = 1; i <= n; i ++) {
        if (!color[i])
            if (!dfs(i, 1)) {
                flag = true;
                break;
            }
    }
    if (!flag) puts("Yes");
    else puts("No");
    
    return 0;
}
```
## 匈牙利算法（增广路法）

二分图中“任意两条边都没有公共端点”的边的集合即为二分图匹配。最大值就是集合点的个数的最小值。
解决**二分图最大匹配问题**。依旧使用DFS实现。

算法思想：待字闺中，我自取之；名花有主，求他换个。
时间复杂度：O（mn）

>存储

- `match[n]` 记录该点和哪个点已经进行了匹配。
- **`visit[n]/st[n]`**：每次找边时，避免重复找。**另一个重要的原因，标记这个边该点想用，希望之前匹配的点换个。**
- 邻接表应该存的是左边集合的出边，因为是求左边的换个右边的。

> DFS

- 返回值表示这个点是否匹配成功
- 参数为需要匹配的点。
- 遍历所有出边，如果未匹配(`match[N] == 0`)或者可以换个那么当前点匹配成功
### 模板

模板题：[861. 二分图的最大匹配 - AcWing题库](https://www.acwing.com/problem/content/863/)

>注意问题

- 是稠密图，但仍然使用了邻接表存？因为方便找边？

```cpp
#include <iostream>
#include <cstring>

const int N = 510, M = 100010;

int n1, n2, m;
int h[N], e[M], ne[M], idx;
int st[N];
int match[N];

int add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

bool dfs(int u) {
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!st[j]) {
            st[j] = true;
            
            if (!match[j] || dfs(match[j])) {
                match[j] = u;
                return true;
            }
        }
        
    }
    
    return false;
}

int main() {
    scanf("%d%d%d", &n1, &n2, &m);
    
    memset(h, -1, sizeof h);
    
    while (m --) {
        int a,b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }
    
    int ans = 0;
    for (int i = 1; i <= n1; i ++) {
        memset(st, false, sizeof st);
        if (dfs(i)) ans ++;
    }
    
    printf("%d\n", ans);
}
```