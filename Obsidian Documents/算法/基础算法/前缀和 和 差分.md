用于求区间和，防止重复枚举降低复杂度（有点类似dp？）。
区间和即为两个前缀和的差值。

步骤：
1. 求前缀和
2. 求区间和
## 一维前缀和

求前缀和公式：`pre[i] = pre[i - 1] + a[i];`
为了保证这个公式通用，因此从1开始。
求区间和：`ans = pre[r] - pre[l - 1];`
## 二维前缀和

**模型**：
![500](Pasted%20image%2020230822233642.png)
递推公式：`pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + a[i][j];`

**区间和计算**：
![500](Pasted%20image%2020230823000503.png)

二维前缀和、区间和计算基于容斥原理。

区间和：`ans = pre[x2][y2] - pre[x1 - 1][y2] - pre[x2][y1 - 1] + pre[x1 -1][y1 - 1];`

# 差分

作用：原来在a前缀和数组上进行**范围+c操作**，可以转化为在b差分数组上的a[l]+c和a[r+1] -c操作。由O(N)变成了O(1)

差分和前缀和是一对逆运算。
也是分为一维和二维。
根据前缀和，构造原数组。
![](Pasted%20image%2020230930192618.png)

![](Pasted%20image%2020230930230122.png)

将差分数组和范围+操作统一，即看成原来的a数组都为0，然后进行
[i, i]的+c操作。统一范围加和差分数组构造的操作。

a 是b的前缀和数组，b是a的差分数组
> 一维差分模板
```cpp
int n, m;
int a[N], b[N];

void insert(int l, int r, int c) {
	b[l] += c;
	b[r] -= c;
}

int main() {
	
	for (int i = 1; i <= n; i ++) scanf("%d", &a[i]);
	// 构造差分数组
	for (int i = 1; i <= n; i ++) insert(i, i, a[i]);

	int l, r, c;
	scanf("%d%d%d", &l, &r, &c);
	insert(l, r, c);

	for (int i = 1; i <= n; i ++) b[i] += b[i - 1];
	for (int i = 1; i <= n; i ++) printf("%d ", b[i]);
}
```

> 二维差分模板

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
int n, m, q;
int a[N][N], b[N][N];

void insert(int x1, int y1, int x2, int y2, int c) {
	b[x1][y1] += c;
	b[x1][y2 + 1] -= c;
	b[x2 + 1][y1] -= c;
	b[x2 + 1][y2 + 1] += c;
}

int main() {
	cin >> n >> m >> q;
	for (int i = 1; i <= n; i ++) 
		for (int j = 1; j <= m; j ++)
			scanf ("%d", &a[i][j]);
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= m; j ++)
			insert(i, j, i, j, c);
	while (q --) {
		int x1, y1, x2, y2, c;
		cin >> x1 >> y1 >> x2 >> y2 >> c;
		insert(x1, y1, x2, y2, c);
	}

	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= m; j ++)
			b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];

	for (int i = 1; i <= n; i ++) {
		for (int j = 1; j <= m; j ++)
			printf("%d ", b[i][j]);
		puts("");
	}
}
```