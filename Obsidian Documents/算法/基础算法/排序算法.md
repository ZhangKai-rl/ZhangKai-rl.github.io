![](Pasted%20image%2020230412200339.png)
# 快速排序

基于比较，**分治**思想
每次能确定一个元素（pivot）的位置
## 思想：

- 选定pivot轴
-  将大于pivot的放右边，将小于pivot的放左边
- 对左右子序列重复上述操作
## 步骤

1. 确定分解点：取l, (l + r) / 2, r, 随机四种常见取pivot方式。
2. **调整区间**：小于pivot的在其左边，大于pivot的在其右边。难点
3. 递归：递归处理左右两个区间。
---
一种暴力做法：
开两个数组a，b
将q中大于x的放于a数组，小于x的放于b数组
之后再将a数组中的放到q中，再放x，最后放b数组，时间复杂度也是o（n）的，进行了两次线性扫描。
递归调整。
## 特点

时间复杂度：O(nlogn)
空间复杂度：
是否稳定：不稳定
## 模板

数据量比较大，建议使用scanf而非cin。
使用cin前，加入语句`ios::sync_with_stdio(false);`，使得cin和stdin不同步。此时大多数情况下和scanf一样快。java的话使用bufferread而非scanner。

yxc模板
```cpp
void quick_sort(int q[], int l, int r) {
	if (l >= r) return ;
	int x = q[l], i = l - 1, j = r + 1;
	while (i < j) {
		do i++; while (q[i] < x);
		do j--; while (q[j] > x);
		if (i < j) swap(q[i], q[j];
	}
	quick_sort(q, l, j);
	quick_sort(q, j + 1, r);
}
```

```cpp
void quick_sort(int arr[], int low, int high) {
	if (low < high) {
		int mid = partiton(arr, low, high);
		quick_sort(arr, low, mid - 1);
		quick_sort(arr, mid + 1, high);
	}
}
int partition(int arr[], int left, int right) {
	int pivot = left;
	int i = left, j = right;
	while (i < j) {
		while (i < j && arr[j] >= arr[pivot]) {
			j --;
		}
		while (i < j && arr[i] <= arr[pivot]) {
			i ++;
		}
		swap(arr[i], arr[j]);
	}
	swap(arr[pivot], arr[i]);
	return i;
}
```
# 归并排序
## 思想

分治递归思想。
与快速排序不同的是先进行分治递归，然后进行合并。

## 模板
```cpp
void merge_sort(int q[], int l, int r) {
	if (l >= r) return ;
	int mid = l + r >> 1;
	merge_sort(q, l, mid), merge_sort(q, mid + q, r);
	int i = l, j = mid + 1, k = 0;
	while (i <= mid && j <= r) {
		if (q[i] < q[j]) tmp[k ++] = q[i ++];
		else tmp[k ++] = q[j ++];
	}
	while (i <= mid) tmp[k ++] = q[i ++];
	while (j <= r) tmp[k ++] = q[j ++];

	for (i = l, k = 0; i <= r; i ++) q[i] = tmp[k ++];
}
```

# 堆排序
## 堆

时间复杂度：
空间复杂度：
数组模拟，==下标从1开始==。左儿子：2n，右儿子：2n + 1。如果从0，开始那么公式不具有普适性。

>==堆的基本操作==

- 插入一个数：heap[++size] = x, up(size);
- 求最小值：heap[1];
- 删除最小值：heap[1] = heap[size]，size --, down(1);
- 删除任意一个元素：heap[k] = heap[size], size --, down(k), up(k);
- 修改任意一个元素：heap[k] = x, down(k), up(k);

两个核心操作up 和 down
## 模板

yxc
```cpp
void down(int u) {
	int t = u;
	if (u * 2 <= cnt && h[u * 2] > h[u]) t = u * 2;
	if (u * 2 + 1 <= cnt && h[u * 2 + 1] < h[u]) t = u * 2 + 1;
	if (t != u) {
		heap_swap(t, u);
		down(t);
	}
}

void up(int u) {
	int t = u
	while (u / 2 && h[u / 2] > h[u]) {
	heap_swap()
}

// build heap
for (int i = n / 2; i; i --) down(i);
int min = heap[1], heap[1] = heap[cnt --], down(1);
```




```cpp
void heap_sort(int arr[], int n) {
	// 先建堆
	for (int i = (n - 1 - 1) / 2; i >= 0; i--) {
		heapify(arr, n, i);
	}
	// 排序
	for (int i = n - 1; i > 0; i--) {
		swap(arr[i], arr[0]);
		heapify(arr, i, 0);
	}
}

// 调整堆的i节点，使其符合性质
void heapify(int arr[], int n; int i) {
	int largest = i;
	int lson = 2 * i + 1;
	int rson = 2 * i + 2;
	if (lson < n && arr[largest] < arr[lson]) {
		largest = lson;
	}
	if (rson < n && arr[largest] < arr[rson]) {
		largest = rson;
	}
	if (largest != i) {
		swap(arr[largest], arr[i]);
		heapify(arr, n, largest);
	}
}
```

# 拓扑排序

有两种实现方式：
- 卡恩Kahn算法（BFS）
- DFS

## 模板
BFS：核心为使用队列
算法步骤：
1. 队列q压入所有入度为0的点
2. 每次从q中取出一个点放入拓扑序列tp
3. 遍历其出边（en），减少出边的入度，如果入度减为0，加入q
4. 重复2， 3直至q为空(遍历每个出度为0的点)
5. 如果tp元素数为n，则有拓扑序列，否则有环。
```cpp
vector<int> e[N], tp;
int din[N];

bool toposort() {  // 如果有拓扑序列，返回true
	queue<int> q;
	for (int i = 1; i <= n; i ++) {
		if (din[i] == 0) q.push(i);
	}

	while (q.size()) {
		int x = q.top(); q.pop();
		tp.push_back(x);
		for (auto edge : e[x]) {
			if (--din[edge] == 0) q.push(edge);
		}
	}

	return tp.size() == n;
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i ++) {
		cin >> a >> b;
		e[a].push_back(b);
		din[b]++;
	}

	toposort();
}
```