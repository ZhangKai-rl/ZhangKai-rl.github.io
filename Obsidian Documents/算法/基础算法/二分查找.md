# 思想

二分查找需要有序。
有单调性一定可以二分，没有单调性有时也可以二分。
本质是边界，找到一个边界，一半满足某个性质，另一半不满足该性质。此时二分可以找两种区间的边界。二分两个区间没有交点。
![](Pasted%20image%2020230912013355.png)
有两个模板，分别二分出红色边界、绿色边界。

# 卡尔二分

使用左闭右闭区间，用于单纯查找指定值的下标
```c++
int left = 0, right = nums.size() - 1;
while (left <= right) {
	int mid = left + (right - left) >> 1;

	if (nums[mid] == target) return mid;
	else if (nums[mid] < target) left = mid + 1;
	else if (nums[mid] > target) right = mid - 1;
}
returrn -1; // 此时说明并不存在target
```
缺点：只能找到指定的值，而无法确定此值所在区间。最好是用于==无重复数组==

# yxc二分查找

时间复杂度：
空间复杂度：
## 整数二分

步骤：先写一个check函数，然后check(mid)考虑true,false时如何更新区间。

依旧使用左闭右闭区间，==可以查找重复指定值所在区间==

查找区间左端点
```c++
int left = 0, right = nums.size() - 1;
while (left < right) {
	int mid = left + right >> 1;
	if (nums[mid] < target) left = mid + 1;
	else right = mid; // 关键所在，相等时选择了左区间
}
// 最后left和right都指向了左区间端点。
// 也有可能是没找到
return nums[left] == target ? left或者right : -1;
```
查找区间右端点
```c++
int left = 0, right = nums.size() - 1;
while (left < right) {
	int mid = left + right + 1 >> 1;
	if (nums[mid] > target) right = mid - 1;
	else left = mid; // 相等时选择了有区间
}
最后找到的可能是右端点或者没有找到。
return nums[right] == target ? left : -1;
```
## 浮点数二分

浮点数没有向上向下取整问题，所以没有边界问题
```cpp
float binary_float(float l, float r) {
	while (r - l > 1e-5) {
		int mid = l + r >> 1;
		if (check(mid)) l/r = mid;
		else r/l = mid;
	}
	return l/r;
}
```