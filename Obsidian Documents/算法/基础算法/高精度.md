高精度加减乘除
其中乘法一个为高精度，除法中被除数为高精度。

>存储方式

输入处理，不能使用int，使用string，然后倒序存储到vector中。
使用vector来进行存储，从低位到高位存储，方便进位。

## 模板

>加法

```cpp
vector<int> add(vector<int> &A, vector<int> &B) {
	vector<int> C;
	int carry = 0;
	for (int i = 0; i < A.size() || i < B.size() || t; i ++) {
		if (i < A.size()) carry += A[i];
		if (i < B.size()) carry += B[i];
		C.push_back(carry % 10);
		carry /= 10;
	}
	return C;
}
```

>减法

减法需要判断a和b的大小。保证始终是大的减小的。
```cpp
bool cmp(vector<int> &A, vector<int> &B) {
	if (A.size() != B.size()) return A.size() > B.size();
	for (int i = 0; i < A.size(); i ++) {
		if (A[i] != B[i]) return A[i] >= B[i];
	}
	return true;
}

vector<int> sub(vector<int> &A, vector<int> &B) {
	vector<int> C;
	int borrow = 0;
	for (int i = 0; i < A.size(); i ++) {
		borrow = A[i] - borrow;
		if (i < B.size() t -= B[i];
		C.push_back((borrow + 10) % 10);
		borrow = borrow < 0 ? 1 : 0;
	}
	while (C.size() > 1 && C.back() == 0) C.pop_back();
}
```

>乘法

```cpp
vector<int> mul(vector<int> &A, int b) {
	vector<int> C;
	int carry = 0;
	for (int i = 0; i < A.size(); i ++) {
		carry += A[i] * b;
		C.push_back(carry % 10);
		carry /= 10;
	}
	while (C.szie() > 1 && C.back() == 1) C.pop_back();
	return C;
}
```

>除法

除法要输出两个值，商和余数。
除法是从高位除起，但是为了和其他三个保持一致，仍采取相同的存储方式。
```cpp
vector<int> div(vector<int> &A, int b, int &r) {
	vector<int> C;
	int r = 0;
	for (int i = A.size() - 1; i >= 0; i --) {
		r = r * 10 + A[i];
		C.push_back(r / b);
		r %= b;
	}
	reverse(C.begin(), C.end());
	while (C.size() > 1 && C.back() == 0) C.pop_back();
}
```