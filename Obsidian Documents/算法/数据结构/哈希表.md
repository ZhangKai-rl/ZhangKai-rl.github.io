类似于离散化，但是不保证原来的顺序。是一种期望算法。一般只有插入、查找操作，不会删除。删除一般打标记。

根据解决哈希冲突的方式不同，分为：开放地址和拉链哈希表。

# 模板

## 拉链法

拉链法和图论的存储结构相同。
```cpp
#include <iostream>

const int N = 100003; // 取质数

int h[N], e[N], ne[N], idx;

void insert(int x) {
	int k = (x % N + N) % N;
	e[idx] = x, ne[idx] = h[k], h[k] = idx ++; 
}

bool find(int x) {
	int k = (x % N + N) % N;
	for (int i = h[k]; i != -1; i = ne[i]) {
		if (e[i] == x)
			return true;
	}
	return false;
}

int main() {
	int n;
	scanf("%d", &n);

	memset(h, -1, sizeof h);
}
```

## 开放寻址法（线性探测法）

更为常用。
只有一个一维数组，大小为题目数据范围的2~3倍。

开放寻址法的核心是find函数，如果找到返回下标，找不到返回应该插入的下标。

```cpp
#include <iostream>

using namespace std;

const int N = 200003, null = 0x3f3f3f3f;**********

int h[N];

int find(x) {***
	int k = (k % N + N) % N;
	while (h[k] != null && h[k] != x) {
		k ++;
		if (k == N) k = 0;
	}
	return k;
}

int main() {
	int n;
	scanf("%d", &n);

	memset(h, 0x3f, sizeof n);*******************
}
```

# 字符串哈希

## 模板

```cpp
#include <iostream>

using namespace std;

typedef unsigned long long ULL;
const int N = 100010, base = 131;

char str[N];
ULL h[N], p[N];

int get(int l, int r) {
	return h[n] - h[l - 1] * p[l - r + 1];
}

int main() {
	int n, m;
	scanf("%d%d", &n, &m);
	scanf("%s", str + 1);
	
	p[0] = 1;
	for (int i = 1; i <= n; i++ ) {
		h[i] = str[i - 1] * base + str[i] - 'a' + 1;
		p[i] = p[i - 1] * base;
	}

	while (m --) {
		int l1, r1, l2, r2;
		scanf("%d%d%d%d", &l1, &r1, &l2, &r2);
		if (get(l1, r1) == get(l2, r2)) puts("Yes");
		else puts("No");
	}
}
```