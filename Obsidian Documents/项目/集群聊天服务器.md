[项目github地址](https://github.com/fixbug666/chatserver)

# Json

使用nlohmann的json三方库进行数据的序列化和反序列化。
![你好](Pasted%20image%2020230801154754.png)

>为什么进行序列化？

将数据写入文件或者通过网络发送时，必须将其编码为某种自包含的字节序列，易于解析，提供了效率。从内存中的表示到字节序列的转化成为序列化。基本上只要是涉及到**跨平台存储**或者进行**网络传输**的数据，都需要进行序列化。**使之独立于编程语言，来表示和存储数据。**

## 序列化

建立一个json对象
然后`string sendBuf = json.dump(), sendBuf.c_str()`；将json对象，转换成json字符串即可在网络中进行发送。
==在网络中发送和收到的都是json格式的string==

## 反序列化

string => json对象
`string recvBuf; json jsbuf = json::parse(recvBuf)`。
放入json前是什么类型，拿出来仍然是什么类型

# chatservice

做业务，**聊天服务器业务类。**将网络模块和业务模块进行解耦合。
**有一个对象就够了，使用单例模式。**
根据消息id，来决定相应的处理方式。

>

>客户端异常退出处理

需要对该用户的状态进行合理修改。
使用`ChatService::clientCloseException(const TcpConnectionPtr &conn)`来处理。

>一对一聊天消息处理

![](Pasted%20image%2020230802130144.png)
如果在线，根据id找到对应的tcpconnection，然后调用其send方法将消息发送过去；
不在线存入离线消息表（offlinemessage表）里面。

## 群组业务

组和成员的关系是多对多的关系，因此需要一张中间表来体现他们的关系即groupuser表

# 数据库

ORM框架
业务层操作的都是对象，DAO层操作的是数据库操作（SQL)。
chatservice是业务层，不应出现任何直接操作数据库操作，要操作对象。

## mysql连接

先使用一个mysql类，对mysql连接和基本操作进行封装。

## 表-对象映射类

每个表定义一个类。将数据库内容提取出来后合成一个对象。
根据实际的数据库表来设计其对应类。

### model类

对每个表类，设计一个model类，如：usermodel类。
负责实际的和数据库的操作。
这个表设计的增删改查操作。

# 分布式

默认fd为1024，调大后单机最多支持2w个。
nginx在提高并发量，可以加入LVS达到十几万。一个LVS带多个nginx

>nginx使用什么负载均衡算法？

>跨服务器如何通信？

使用中间件消息队列。
![](Pasted%20image%2020230802191837.png)

## nginx负载均衡

conf目录下的nginx.conf
![](Pasted%20image%2020230802194526.png)
监听8000端口，然后将请求分发到6000和6002端口

nginx -s reload平滑加载配置文件






# 集群聊天服务器项目总结

首先，我是在Linux下使用VScode进行项目的开发，通过Cmake构建项目，使用gdb进行项目问题的调试，项目完成后通过Linux shell输出项目编译脚本，并把项目托管到我的GitHub上。

这个项目分为4个模块，首先，第一个模块是网络模块，我通过深入剖析muduo网络库的核心组件，采用C++11重写muduo库的核心组件，将依赖于boost库的技术点转化为C++11的知识点，使其脱离boost库，实现出一套网络库来使用，使用这个网络库的好处是：解耦了网络模块的代码和业务层的代码，能够让开发者专注于业务层的开发。然后第二个模块是业务模块，也就是是服务层，我使用了C++11的一些技术，比如说，map，绑定器，函数对象，做了一个消息id和这个消息发生以后的回调操作的绑定，相当于是做了一个回调机制，当这个网络I/O给服务器通知有消息请求，服务器处理客户注册的读事件的回调操作(OnMessage)，通过消息请求，从消息里面(buffer)解析出这个json，得到消息id，通过回调操作，就可以处理这个消息了。第三个是数据存储层，我使用的是MySQL，对于项目的关键的数据进行存储，比如说，用户的id，离线消息，好友列表，群组列表的关系，都是在MySQL存储。我还通过实现一个MySQL数据库连接池，在项目代码上还通过书写model类对业务层封装底层数据库，提高MySQL数据库的访问效率。
在单机模式下，主要就是这3个模块，但是单机的并发能力是有限的，所以，我考虑项目的整体的并发能力，让项目可以支持多机的扩展，部署多台网络服务器，前面需要挂1个Nginx负载均衡，这个项目是基于TCP的私有协议，自己去搭建的基于C/S模型的通信，所以我通过对Nginx的tcp的负载均衡配置，做一个长连接，因为是消息聊天通信，客户端不仅仅要给服务器主动发消息，而且服务器还要主动给客户端推消息，所以必须是长连接，短连接做不到这个功能，因为短连接没有办法给客户端推消息，另外，在负载均衡里面，因为是各个服务器有不同的人进行注册，不同服务器上注册的用户需要进行通信的话，我在这里引入了Redis作为一个MQ消息队列的功能，利用它的发布订阅功能实现了跨服务器的消息通信功能。