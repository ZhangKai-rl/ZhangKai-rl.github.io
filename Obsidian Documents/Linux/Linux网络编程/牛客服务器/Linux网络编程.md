面试官喜欢问这些

B/C和C/S架构
端口号占16位，2字节，最大65535
每个socket都有一个都缓冲区一个写缓冲区
# 实战
多进程/多线程实现TCP并发服务器
# TCP
![](Pasted%20image%2020230227223018.png)

## 握手及挥手
序号seq是32位的。
ack表示期待收到的下一个字节流的首序号（seq+长度（有SYN/FIN时要再加一））。
SYN和FIN带有一个数据的，计算式不要忘记。
### 三次握手
在客户端进行connect时进行
![](Pasted%20image%2020230227151505.png)
第一次握手时还没有建立连接只是申请，不能发送数据。
### 四次挥手
发生在断开连接（断开连接的原因是释放资源），程序中调用close时进行。
![](Pasted%20image%2020230227153350.png)
握手时二三步合为了一步，为什么这里不合成？
	因为此时只是客户端想断开连接，服务器还可能要继续发送数据。而建立连接时已经回复ack了那么一定也是想建立连接的。
客户端FIN时可以带有数据。

## TCP滑动窗口（sliding window）
是一种流量控制技术
接受方告诉发送方在某一时刻能发送多少包（窗口尺寸）
通信双方都有发送接收数据的缓冲区（环形队列）。 
![](Pasted%20image%2020230227152525.png)
mss：Max Segment Size（一条数据最大的数据量），最大报文段。
win：滑动窗口大小，代表的是我的win的大小
![](Pasted%20image%2020230227152738.png)
## TCP通信并发
如果服务器端接受多客户端要多次accept，但是通信过程是个死循环接受数据。
因此要使用多线程或者多线程来实现TCP服务器并发。主线程循环accept，并且创建子进程来通信。子进程循环收发数据

## TCP状态转换
握手
![](Pasted%20image%2020230227184749.png)
挥手谁发起都可以
![](Pasted%20image%2020230227185220.png)
TIME_WAIT经过2倍报文寿命（2MSL）后变成CLOSED？
	因为最后有可能服务器没接收到ACK，此时服务器不能变为CLOSED，会再次给客户端发送FIN直到服务端收到ACK为止。
	确保另一方能收到ACK。
	msl官方建议2分钟，实际上是30s
LAST_ACK前，服务器还是可以继续发送数据的。
## 半关闭和端口复用
### 半关闭：
完成了前两次挥手，关闭了一端。调用close之后不能发送数据，能接收数据。
![](Pasted%20image%2020230227190505.png)
close关闭了socket的读和写的fd，不能实现半关闭状态。
![](Pasted%20image%2020230227190647.png)
![](Pasted%20image%2020230227190732.png)
### 端口复用
![](Pasted%20image%2020230227193819.png)
防止TIME_WAIT时，重新启动服务器显示端口已被占用的情况。

# I/O多路复用（I/O多路转接）

含义：I/O多路复用，多条路复用成一条。使得程序能同时监听多个文件描述符，能提高程序的性能。Linux下实现I/0多路复用的系统调用主要有select、poll、epoll。
输入：从文件中写到内存中。
输出：从内存中数据读到文件中。
Block I/O
![](Pasted%20image%2020230227200753.png)
![](Pasted%20image%2020230227200921.png)
![](Pasted%20image%2020230227201051.png)
调用1w次系统调用来查询fd是否有数据。
![](Pasted%20image%2020230227201308.png)
![](Pasted%20image%2020230227201323.png)
## select
为什么是1024？
	因为是long int类型，一共8字节，8 * 128 = 1024位，1/0表示不同的状态，因此最多表示1024个fd.
使用bitmap来表示fd
![](Pasted%20image%2020230227201938.png)
readfds有1024位（文件描述符有1024位，8字节），有数据的置1.
writefds
![](Pasted%20image%2020230227202707.png)
大于0表示有n个描述符发生了变化。
nfds：文件描述符集合的需要遍历的数量。因此是最大的+1.
![](Pasted%20image%2020230227203220.png)
首先FD_SET置1来表示需要检测，拷贝到内核态;然后内核态遍历时遇见置位1的就去检测缓冲区是否有数据，有的话将其置位1，没有置位0,然后再重新拷贝到用户态。两次1，0表示不同的意义。创建一个tmp = rdset，让内核去修改rdset，rdset里面的1始终代表内核需要检查的文件描述符表。
内核遍历文件描述符表，从0遍历到nfds，然后查看置位1的缓冲区来决定是否重新置1.
![](Pasted%20image%2020230227205739.png)
4对应tmp
## poll
select的改进
内核改的是revents，需要检测的是events，因此不需要重置fds。
是个结构体不是数组，没有1024的限制
![](Pasted%20image%2020230227210411.png)
依旧需要再用户态遍历查看具体是哪个fd发生了变化。
![](Pasted%20image%2020230227210742.png)
数组中每个元素表示一个文件描述符。可以用的fd标为-1.
select中是每一位。
![](Pasted%20image%2020230227211016.png)
poll改进了select的三四条缺点。
## epoll
不仅检测到有几个发生了改变，还具体返回发生了改变的fd。
==epoll在内核区创建了一片数据结构==，通过文件描述符来使用。
rbr采用红黑树，记录需要检测的文件描述符。
rdlist检测到有数据改变的fd。使用双链表。
![](Pasted%20image%2020230227213942.png)
![](Pasted%20image%2020230227214201.png)
epllo fd需要关闭。
### epoll的工作模式
![](Pasted%20image%2020230227215930.png)
ET模式要配合循环读数据，非阻塞的read api（通过设置fd属性）
LT模式中发送一次数据，服务器读缓冲中没有读完，会一直调用epoll_wait函数，直至没有数据。
ET不是默认，要手动设置。在epoll_envnt中加入epollet（或上）。
![](Pasted%20image%2020230227221956.png)
此处read必须不阻塞，如果阻塞在这，其余的没法读。

# UDP
用户数据报协议，可以单播、组播、广播。
![](Pasted%20image%2020230227222610.png)
## 广播
发送到子网中所有IP的指定端口。
广播一般适用于局域网，多播可以广域网。
## 组播
服务器发给多播地址
![](Pasted%20image%2020230227224616.png)
服务器端需要设置多播属性，客户端需要加入多播组。

# 本地套接字
实现本地进程间通信。
![](Pasted%20image%2020230227230009.png)
![](Pasted%20image%2020230227230212.png)
创建伪文件，对应内核中的缓冲区。