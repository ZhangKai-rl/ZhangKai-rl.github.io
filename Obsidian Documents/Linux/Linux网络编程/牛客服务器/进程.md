# 定义
## 程序和文件
- 程序是包含一系列信息的文件，描述了如何在运行时创建一个进程。包括：数据、程序入口地址、共享库动态链接信息、机器语言指令等。是死的
- 进程是正在运行的程序的实例。是活的，占用内存和cpu。是基本的分配单元，也是基本的执行单元。每个进程都有自己的PCB。是内核定义的抽象实体。
## 单道多道程序设计
![](Pasted%20image%2020230224172650.png)
## PCB
Linux中是task_struct结构体。
### 数据成员
![](Pasted%20image%2020230224181435.png)
![](Pasted%20image%2020230224181524.png)
# 进程的状态
- 三态模型：就绪、运行、阻塞
- 五态模型：新建、就绪、运行、阻塞、中止
![](Pasted%20image%2020230224181844.png)
就绪：以获得除cpu外的所有必要资源，只等待分配cpu就可以运行，进入就绪队列。
阻塞：也叫等待、睡眠态。不具备运行条件，等待某个事件的完成。
# 进程相关命令
- ![](Pasted%20image%2020230224182217.png)
   输出的是静态的快照信息。tty表示所属终端
- tty：显示当前终端编号
- ![](Pasted%20image%2020230224182714.png)
- ![](Pasted%20image%2020230224183014.png)
# 进程号和相关函数
任何进程都有父进程，除了init
![](Pasted%20image%2020230224183257.png)
# 进程创建
![](Pasted%20image%2020230224184128.png)
==fork返回值==，返回-1表示创建失败。
子进程从fork的位置往下执行。不然会无限套娃。
## 父子进程虚拟空间
用户区和内核区都拷贝一份，但是内核区中，父子进程的pid和ppid不相同。fork的返回值存到用户区的栈空间中，也不相同。
两者空间独立，互不影响。
![](Pasted%20image%2020230224190727.png)
fork，父子进程读时共享，写时拷贝。
## exec函数族
### 原理
![](Pasted%20image%2020230224201516.png)
替换当前进程。神变形不变。因此一般是fork个子进程，子进程中执行exec。替换用户区，内核区不变
### 函数
![](Pasted%20image%2020230224202034.png)
![](Pasted%20image%2020230224202717.png)
出错时才会有返回时（调用成功后代码区被替换，失败后没被替换因此可以返回），返回值为-1，并且设置perror。
参数最后必须是NULL空指针结尾！
	execlp：
		![](Pasted%20image%2020230224204449.png)
		会到环境变量中找可执行文件，不需要路径，找不到会报错。
# gdb多进程调试
![](Pasted%20image%2020230224191051.png)
默认追踪父进程，子进程直接执行完（follow-fork-mode默认为parent，detach-on-fork默认为on）

# 进程控制
## 进程退出
![](Pasted%20image%2020230225150208.png)
## 孤儿进程、僵尸进程
孤儿进程：父进程结束，子进程还在继续。孤儿进程的父进程被设置成pid为1的init进程，init循环wait子进程。孤儿进程没有危害
僵尸进程：进程终止，自己释放掉了用户区数据，但是内核区PCB没法自己释放，父进程尚未将其释放。不可以被kill -9 杀死。等待父进程使用wait或者waitpid。会一直占用pid，系统pid是邮箱的，如果没有可用pid就无法产生新的进程，这就是僵尸进程的危害。
## wait函数
父进程调用wait或者waitpid得到子进程退出状态，并清除PCB信息。
wait会阻塞，waitpid可以不阻塞，并且可以指定等待子进程号
一次wait、waitpid只能清理一个子进程
参数为传出参数，写入子进程推出的状态信息。
# 进程通信IPC
## 目的
- 数据传输
- 资源共享
- 通知事件
- 进程控制：如debug
## 方式
![](Pasted%20image%2020230225151249.png)
### 管道
需要进行内核去用户区转换。
>
>管道也叫匿名管道，是unix最古老ipc通信。管道符号 |
![](Pasted%20image%2020230225151404.png)
>> ==管道特点==
>> - 管道是内存中的的一个缓冲区，大小有限
>> - 拥有文件特质：可以读写操作，但是匿名管道没有文件实体，有名管道有文件实体，但是不存储数据，可以按操作文件的方式对管道进行操作。管道两端分别有一个fd。操作管道就是操作fd。
>> - 管道是一个字节流，可以读取写入任意大小数据块。
>> - 数据结构类似于队列，数据时顺序的。
>> - 半双工，同一时间，只能一端读一端写。
>> - 读数据是一次性操作，读完就被抛弃，无法使用lseek随机访问数据。
>> - 只能用在父子，兄弟，有亲缘关系的进程间。（因为她不能指定fd，有亲缘关系的进程内核区PCB中的fp表中有相同fp拷贝，可以指向同一管道）。
>
>> 管道数据结构
>> 环形队列，不会造成空间资源的浪费。
>
>> ==管道读写特点==
>> 	读管道：
>> 		管道中有数据：read返回实际读字节数。
>> 		管道中无数据：
>> 			写端全部关闭（写段fd引用计数为0），read返回0（相当于读到文件结尾）
>> 			写端没有完全关闭：read阻塞（等待写端写入）
>> 	写管道：
>> 		管道读端全部关闭，进程异常终止（进程收到SIGPIPE信号，没有读的，写会终止）
>> 		读端没有完全关闭：
>> 			管道已满：write阻塞（等待读端将数据读出）
>> 			未满：write写入数据，返回实际写入字节数。
>
>> 设置管道非阻塞
>> 	实际就是设置fd非阻塞（使用fcntl）。通过设置两端的fd非阻塞，来分别实现写不阻塞和读非阻塞。
>> 	设置非阻塞就是读写管道的时候不阻塞的意思
>
>> 管道创建
>>  ![](Pasted%20image%2020230225154603.png)
>>  pipefd是个传出参数，将管道的两个fd写入其中。


> 有名管道（FIFO）
> >提出是为了克服管道只能用于亲缘关系IPC的缺点。也叫命名管道、FIFIO文件。重点是有了路径，不相关进程通过访问这一路径来实现IPC.
> >与匿名管道的区别
> >	提供了路径名与之关联。以FIFO文件（不存储数据）的形式存在于文件系统中
> >使用
> >>![](Pasted%20image%2020230225153802.png)
> >>只是创建了管道fifo文件，操作有名管道需要open获取fd
> > ==有名管道**只有一个fd**，读默认从头，写默认在末尾==

管道一般一个文件只负责读或者写（关闭写fd或者读fd），实现两个进程相互读写需要两个管道。有名管道使用只读方式，或者只写方式打开fifio文件来实现。

### 内存映射
共享内存就是两个进程操作同一个文件的内存映射
#### 定义
将磁盘文件的数据映射到内存中进程的虚拟地址中，让用户通过修改内存来修改磁盘文件。
![](Pasted%20image%2020230225165605.png)
#### 函数
![](Pasted%20image%2020230225165949.png)
![](Pasted%20image%2020230225170352.png)
fd：需要操作的文件的fd，通过open得到，是一个磁盘文件。
offset：文件开头的偏移量。
==重点在flags里面的MAP_SHARED==,内存映射实现共享内存IPC的关键。
返回创建的内存映射的首地址，失败返回MAP_FAILED.
![](Pasted%20image%2020230225170556.png)
![](Pasted%20image%2020230225170657.png)
两个文件得是一样的。
==共享内存IPC是不阻塞的。==
#### 注意问题
![](Pasted%20image%2020230225171540.png)
1. 可以++，但是munmap会出错，必须传入首地址。
2. 错误。两者要保持一致
3. 偏移量必须4K整数倍，会出先MAP_FAILED错误。
4. 以下：
	![](Pasted%20image%2020230225171953.png)
5. 可以，大小不能为0；
6. 不会出问题，映射区还存在，没有任何影响。
7. 越界操作的是非法内存-》段错误。
#### 匿名映射
不需要实体文件，实现有关系进程IPC。
实现：
	mmap参数中![](Pasted%20image%2020230225173423.png)

### 信号
是事件发生时的通知机制。也成为软中断。软件层次商队中断机制的一种模拟，是一种异步通信方式。
可以导致一个正在运行的进程被另一个正在进行的异步进程中断，转而处理某一个突发事件。
![](Pasted%20image%2020230225173921.png)
![](Pasted%20image%2020230225174227.png)
![](Pasted%20image%2020230225174415.png)
![](Pasted%20image%2020230225174519.png)
![](Pasted%20image%2020230225174547.png)
红色的要重点掌握
![](Pasted%20image%2020230225174626.png)
#### 信号相关函数
操作访问野内存会产生段错误。
使用ulimit修改core的值，可以产生core文件
gcc中加入-g选项，使用gdb调试可执行程序core-file core文件名，查看终止信号
![](Pasted%20image%2020230225175305.png)
![](Pasted%20image%2020230225175650.png)
![](Pasted%20image%2020230225175734.png)
![](Pasted%20image%2020230225184231.png)
![](Pasted%20image%2020230225184603.png)

参数为0 表示无效，alarm（0）取消所有定时器，返回值：之前有定时器返回倒计时剩余时间，没有返回0。  
alarm是不阻塞的
实际程序运行时间 = 内核时间 + 用户时间 + IO消耗的时间
setitimer
	参数：
		which：定时器使用什么时间
		new_val：延迟多长时间第一次运行，隔多长时间再运行
		old_value：记录上一次定时的时间参数
	返回值：0成功。-1失败设置错误好。

##### 信号捕捉函数

![](Pasted%20image%2020230225190723.png)
SIGKILL SIGSTOP不能被捕捉和忽略
![](Pasted%20image%2020230225192057.png)
2. 用于检查或者改变信号的处理，信号捕捉。
	![](Pasted%20image%2020230225213300.png)
最好使用sigaction
![](Pasted%20image%2020230225213621.png)

#### 信号集
使用位图来实现。
![](Pasted%20image%2020230225193041.png)
同一时间一种信号只有一位，多的被舍弃，无法记录。
这里的阻塞是阻塞信号递达
sigset_t类型
未决信号集内核维护，我们只能读
这两个信号集都在PCB中。
![](Pasted%20image%2020230225210749.png)
![](Pasted%20image%2020230225210850.png)
这些函数对自定义信号集进行操作
我们创建的信号集都是阻塞信号集
![](Pasted%20image%2020230225211243.png)
![](Pasted%20image%2020230225211313.png)
![](Pasted%20image%2020230225211141.png)
![](Pasted%20image%2020230225211157.png)
![](Pasted%20image%2020230225211417.png)
未决信号集只能读，或者通过系统调用使用内核修改。
这是两个系统调用
1. 功能：将自定义信号集中的数据设置到内核中（设置阻塞、解除阻塞、替换）
	参数：
		-how：如何对内核阻塞信号进行处理。
		![](Pasted%20image%2020230225211958.png)
![](Pasted%20image%2020230225212028.png)
#### SIGCHID信号
![](Pasted%20image%2020230225214122.png)
>用途
>>父进程中捕捉这个信号解决僵尸进程问题。


### 共享内存
效率最高的IPC,大于内存映射，因为内存映射要写回文件。
![](Pasted%20image%2020230225220107.png)
和管道、有名管道关系有点像？
![](Pasted%20image%2020230225220435.png)
![](Pasted%20image%2020230225220830.png)
![](Pasted%20image%2020230225221227.png)
![](Pasted%20image%2020230225222131.png)

![](Pasted%20image%2020230225222019.png)
![](Pasted%20image%2020230225222200.png)
![](Pasted%20image%2020230225222641.png)
![](Pasted%20image%2020230225222916.png)
![](Pasted%20image%2020230225222948.png)

# 守护进程
![](Pasted%20image%2020230225223059.png)
![](Pasted%20image%2020230225223510.png)
![](Pasted%20image%2020230225223802.png)
![](Pasted%20image%2020230225223959.png)
守护进程
![](Pasted%20image%2020230225224431.png)
![](Pasted%20image%2020230225224816.png)
守护进程组长和会长不能一样
1. 其父进程会是组长，如果进行setsid（）那么新建的会话中会新建一个跟他现在的pgid一样的组
2. 开启新会话来脱离当前的控制终端。




