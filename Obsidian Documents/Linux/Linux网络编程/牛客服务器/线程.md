主线程不执行return0，即使退出对其他线程也没有影响。
共享：
线程堆是共享的，栈不是共享的。
# 线程操作
在头文件pthread.h中
![](Pasted%20image%2020230226132007.png)
1. 返回unsigned long int。获取当前线程的tid。
3. start_routine是一个回调函数，子线程来执行
6. pthread_detach(tid) :
	分离一个线程。被分离的线程在终止的时候，不需要join自动释放资源给系统。不能多次分离，不能链接分离的线程。
7. 功能：中途取消线程（让线程终止）。只能在系统规定好的取消点取消，不是立马取消。
## 线程属性操作
![](Pasted%20image%2020230226134135.png)
1. 初始化属性变量
2. 释放线程属性资源
3. 获取线程分离状态属性
4. 设置线程分离状态属性
要先创建线程属性变量，在初始化才能用。最后要销毁。
pthread_attr_t attr    //创建线程属性变量
# 线程同步
![](Pasted%20image%2020230226145413.png)
锁指针都有strict关键字
## 互斥锁
![](Pasted%20image%2020230226145826.png)
![](Pasted%20image%2020230226153130.png)
![](Pasted%20image%2020230226153324.png)
![](Pasted%20image%2020230226153535.png)
互斥量创建要放到全局区：要线程都有，含不能再main，主线程结束就没有了。
## 死锁
![](Pasted%20image%2020230226154944.png)
### 死锁产生的必要田间
- 互斥
- 请求并保持
- 不可剥夺
- 循环等待
## 读写锁
![](Pasted%20image%2020230226160226.png)
读写锁也是一把锁。
![](Pasted%20image%2020230226160551.png)
## 生产者消费者模型
![](Pasted%20image%2020230226164616.png)
条件变量不是锁。作用是引起线程阻塞或者解除阻塞。
wait是等待函数，使当前线程等待。第一个参数是田间变量，第二个是互斥量。阻塞时，会先对互斥量进行解锁，不阻塞时会重新枷锁。
timewait是等待一定时间。
signal唤醒一个或者多个等待的线程
broadcast唤醒所有等待的线程。
## 信号量
![](Pasted%20image%2020230226165452.png)
不能保证线程安全问题，主要作用时阻塞线程。
wait信号量加锁。检查是否为0，是0就阻塞，不为零就-1.
post值+1，解锁信号量.
### 信号和信号量
![](Pasted%20image%2020230226170609.png)
信号只有1，0两个值；信号量可以代表数量。
