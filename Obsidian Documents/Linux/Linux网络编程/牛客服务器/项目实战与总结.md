![](Pasted%20image%2020230228153528.png)# 阻塞非阻塞，同步异步
典型的网络IO接口调用，分为两个阶段：数据就绪和数据读写。
数据就绪分为阻塞和非阻塞，表现的结果是阻塞当前线程或者直接返回。
同步表示A向B请求一个网络IO接口时，数据读写都是由请求方A来完成的（数据就绪可以阻塞也可以非阻塞）；异步表示A向B请求调用一个网络IO接口时，向B传入请求的事件以及事件发生时通知的方式，A就可以处理其他逻辑了，当B监听到事件处理完成后，会用事先约定好的方式通知A处理结果
![](Pasted%20image%2020230228134357.png)

# Linux、Unix上的五种IO模型
BIO
![](Pasted%20image%2020230228134608.png)
EIO
![](Pasted%20image%2020230228135100.png)
前两种单进程/线程只能检测一个IO，无法检测其他客户端。
![](Pasted%20image%2020230228135556.png)
信号在多线程中不好处理，比较麻烦。
![](Pasted%20image%2020230228135959.png)
系统自动通知，而非自己轮询。因此是异步。
![](Pasted%20image%2020230228141308.png)

# Web Server及HTTP
![](Pasted%20image%2020230228143203.png)
浏览器是客户端。HTTP是应用层协议，底层通过传输层的TCP。请求响应消息格式是ASCII形式。默认端口80
![](Pasted%20image%2020230228144908.png)
请求/响应模式
![](Pasted%20image%2020230228145001.png)
![](Pasted%20image%2020230228145220.png)
## HTTP报文
![](Pasted%20image%2020230228145308.png)
请求头下面有个空行
## 状态码
![](Pasted%20image%2020230228150212.png)
## 请求方法
![](Pasted%20image%2020230228150312.png)
## 服务器编程基本框架和两种高效的事件处理模式
![](Pasted%20image%2020230228150513.png)
![](Pasted%20image%2020230228151151.png)
![](Pasted%20image%2020230228153126.png)
![](Pasted%20image%2020230228153538.png)
![](Pasted%20image%2020230228153610.png)
![](Pasted%20image%2020230228153750.png)
![](Pasted%20image%2020230228153843.png)
![](Pasted%20image%2020230228153932.png)

![](Pasted%20image%2020230228154036.png)
![](Pasted%20image%2020230228155446.png)
线程池
![](Pasted%20image%2020230228155605.png)
![](Pasted%20image%2020230228203948.png)


## 有限状态机

从状态机（parse_line）负责读取报文的一行，主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。



服务器响应写分为两块，请求行请求头请求空行和请求体，使用writev进行分散写。

整个程序当中可用的fd是有限的，因此要定时检测不活跃的客户端连接将其关闭。
传统方式，遍历任务数组，看是否超时，超时关闭连接。有数据收发修改超时时间
弊端：需要遍历数组

改进：采用升序双链表保存定时器。

![](Pasted%20image%2020230301222608.png)



优化方向：现在只支持GET；加入数据库相关操作


# 项目问题

定时器容器使用双向链表实现，在调整定时器是效率为O(n)效率偏低

