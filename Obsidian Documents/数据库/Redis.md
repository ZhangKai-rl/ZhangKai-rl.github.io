# 持久化

![](Pasted%20image%2020230705095840.png)
两种方式：
- RDB（RedisDB）：整个redis内存数据**某一个时刻的状态（快照）**持久化到一个磁盘文件
- AOF（append-only file）

## RDB

会在指定目录下生成dump.rdb二进制文件。
优点：**全量数据二进制文件，数据恢复快**。 缺点：**可能会丢数据**。

>Redis在做持久化的同时，内存数据被修改了怎么办？（COW）

redis通过调用fork方式创建子进程进行数据的持久化，所以会保留了持久化开始时刻的数据状况。使用写时复制来处理快照期间的写操作。
fork的特点：`fork`并不会带来明显的性能开销，因为不会立刻对内存进行拷贝，它会将拷贝内存的动作推迟到真正需要的时候。 ​即写时复制。
![](Pasted%20image%2020230705100955.png)

### 命令

save：阻塞主线程，阻塞在fork（）过程中
bgsave：不阻塞主线程。创建子线程专门负责写入RDB
![](Pasted%20image%2020230705100430.png)

## AOF

将redis中每一步对数据修改的操作记录（日志）append到相应的文件中。
为了降低IO消耗，AOF写文件时，会先将数据写到缓冲区，然后再把缓冲区的内容 flush 到磁盘，这个过程叫做 fsync，fsync有三种flush频率：always、everysec、no

# 高可用

主从复制（mysql 通过binlog实现）是redis高可用的基础保证。
实现方案就是将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。
主服务器：1. 读写操作。2. 同步写操作给从服务器。
从服务器：1. 读操作。2. 接受主服务器同步过来的写操作命令并执行。
![](Pasted%20image%2020230705101436.png)
写一读多。异步复制命令。弱一致性。

# 锁

## 分布式锁

可以说是通过setnx + 过期时间来实现的。

Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：
- 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；
- 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。

# 使用

redis是一个C/S结构的，不是类似于leveldb做成一个库。因而具有很多客户端shell 命令。
```shell
get key
set key value
expire key seconds
ttl key
```