# 内存问题
#### C++内存分区
	分为代码段（存放二进制程序代码）、数据段（存放已初始化的全局和静态变量）、bss（未初始化的全局和静态变量，默认为0）、堆（用户动态分配，由低到高）、栈（编译器自动管理，由高到低。包括局部变量，函数参数、返回值等）
#### 内存泄漏
	定义--堆内存：动态申请的内存没有释放；系统资源：socket、fp等没有使用响应函数释放，造成资源浪费。
	危害--正常结束无危害；非正常结束，如僵尸进程会导致系统资源浪费，后期甚至卡死宕机
	检测--valgrind。 避免---1. 提前避免：智能指针 2. 事后排查：检测工具
# 关键字
##### volatile

含义：volatile 关键字是一种类型修饰符，**用它声明的类型变量表示可以被某些编译器未知的因素更改**。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。**volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。**
volatile不是线程安全的，不是原子的。
具体使用场景：状态标记来控制线程流程；单例模式双重检查锁；多线程计数器；轻量级同步。
##### mutable

在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。
有些时候，我们需要**在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置**。
##### explicit

explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以**显式的方式进行类型转换**，注意以下几点：

- explicit 关键字只能用于类内部的构造函数声明上
- 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换
##### final

当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。
##### override

当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写。override指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：
##### extern "C"

为了能够**正确的在C++代码中调用C语言**的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；
使用场景：
（1）C++代码中调用C语言代码；
（2）在C++中的头文件中使用；
（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；
##### const

隐藏：const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以引用声明使用。
const变量：必须定义时初始化，初始化后不可修改（类中要通过构造函数初始化列表初始化）
const函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值。形参可以接收const和非const类型的实参
##### static

隐藏：所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区。
延长作用域：静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用。

- static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。
- static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；**不能被声明为const、虚函数和volatile**；可以被非static成员函数任意访问
##### 宏定义和其他的区别

- **编译阶段**：define是在编译的**预处理**阶段起作用
- **安全性**：define只做替换，不做类型检查和计算，也不求解，容易产生错误
- **内存占用**：define只是将宏名称进行替换，在内存中会产生多分相同的备份。宏替换发生在编译阶段之前，属于文本插入替换；宏定义的数据没有分配内存空间，只是插入替换掉；
**宏定义和内联**
- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
- 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。
- 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
- 内联函数有类型检测、语法判断等功能，而宏没有
# 类
##### 初始化列表

**有些类成员变量他不能定义和初始化分离，比如const 修饰的变量，引用类型变量**
如果自定义对象作为成员属性时若没有默认构造，也需要初始化列表
成员变量的声明次序就是初始化列表初始化次序
如果类存在继承关系，派生类必须在其初始化列表中调用基类的构造函数
与函数体内初始化的区别：
- 初始化列表只是一次调用缺省的构造函数，并不会调用赋值函数。会减少不必要的开支
- 函数体内初始化数据成员时会两次对string的成员函数的调用：一次是缺省构造函数，另一次是赋值。
# C++11
## C++11有哪些新特性