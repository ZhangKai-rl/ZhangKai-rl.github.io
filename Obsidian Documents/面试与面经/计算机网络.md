# TCP协议问题
## TCP连接
### 三次握手
#### 连接建立过程、状态变化、对应函数
![500](Pasted%20image%2020230815020931.png)
![500](Pasted%20image%2020230815021146.png)
#### 为什么是三次握手？不是两次、四次？

三次握手才能保证双方具有接收和发送的能力.
tcp连接必须三次握手才能**初始化 Socket、序列号和窗口大小并建立 TCP 连接。**
- 三次握手才可以阻止重复历史连接的初始化（主要原因）：**在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费**。
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费
#### 丢失一/二/三次握手，会发生什么？
#### 半连接（syn）队列和全连接（accept）队列

都位于服务端。收到第一次握手的syn就放入syn队列中。收到第三次握手的ack就将连接从syn队列中移入accept队列。accept（）函数会从accept队列中取出连接。两个队列都有长度限制，超限直接丢弃（默认）或返回RST包（设置tcp_abort_on_overflow=1）

队列长度：
- accept队列最大长度= **min(somaxconn, backlog)**。backlog为listen参数。之前为syn队列长度，后改为accept队列长度。
##### SYN FIN ACK是否占用seq？

ack不占，syn和fin各占用一个seq
##### SYN 洪泛、SYN 攻击、DDos 攻击。

定义：不断进行第一次握手发送SYN包，但是不进行第三次握手发送ACK包。使得服务端有大量syn队列。
如何防御：
- 增大半连接队列（**增大 tcp_max_syn_backlog 、 somaxconn 和 backlog，也就是增大全连接队列**）
- 开启 tcp_syncookies 功能
- 减少 SYN+ACK 重传次数（第二次握手）
##### 如果syn队列已满，只能丢弃连接吗？

**开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接**。
### 四次挥手
#### 连接断开过程、状态变化、对应函数
![500](Pasted%20image%2020230815021102.png)
#### 为什么要四次？
#### TIME_WAIT和2MSL

TCP基于IP，因此有TTL。
MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡。MSL：30s，TTL：64

为什么需要2MSL ?
	网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**。比如第四次握手ACK丢失，则需要重新三四次握手。
为什么需要TIME_WAIT？
	- 防止历史连接中的数据，被后面相同四元组的连接错误的接收；（为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态）
	- 保证「被动关闭连接」的一方，能被正确的关闭；（**等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。**）

## TCP重传

时间驱动（定时器超时RTO）的超时重传、数据驱动（三个相同ACK）的快速重传、SACK、D-SACK
## TCP窗口

包括：滑动窗口、流量控制、拥塞控制
### 滑动窗口

**滑动窗口的作用**：即使在往返时间较长的情况下，它也不会降低网络通信的效率。不再发一个确认一个。窗口的实现实际上是操作系统开辟的一个缓存空间。
**累积确认/应答**：ack X，表明序号X之前的都已经收到，可以防止ack丢失。
**几个窗口** ：swnd和cwnd都是放在os缓冲区中的。
- swnd：发送窗口，窗口内包括已发送未确认数据和可发送数据（数据总共分为四个部分）。TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节：`SND.WND`、`SND.UNA`、`SND.NXT`。**可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）**
- rwnd：使用两个指针划分为三部分：`RCV.WND`、`RCV.NXT`。rwnd约等于swnd。
- cwnd：swnd = min(cwnd, rwnd)；

**窗口探测**：当rwnd和swnd可用窗口都变为0时，就是发生了窗口关闭。**当发送方可用窗口变为 0 时，发送方实际上会定时发送窗口探测报文，以便知道接收方的窗口是否发生了改变**
#### os缓冲和窗口的关系？

1. 在滑动的时候实际还要受到os缓冲区大小的影响。有些虽然已经确认收到，但是应用并未从os缓冲区中将其读出，rwnd不会往后滑动。当发送方可用窗口变为 0 时，发送方实际上会定时发送窗口探测报文。
2. 当服务端系统资源非常紧张的时候，操作系统可能会直接减少了接收缓冲区大小，此时可能直接丢包。**为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。**
#### 窗口关闭死锁现象？

**如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。**
rwnd窗口大小通过ack报文携带告知。
如果ack报文丢失可能会出现死锁。如上面例子。

为了解决这个问题，TCP 为每个连接设有一个持续定时器，**只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。**如果持续计时器超时，就会发送**窗口探测 ( Window probe ) 报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。
#### 糊涂窗口综合症（nagle算法）？

定义：接收方可用窗口小，接收方报告窗口大小后导致发送方发送窗口小，然后一直发小数据包。
危害：可能数据一共几字节，但是tcp头+ip头为20+20，导致效率特别低
解决：从两个方向解决
- 接收方不报告小窗口：当「窗口大小」小于 min( MSS，缓存空间/2 )，就会向发送方通告窗口为 `0`。
- 发送方不发送小数据包：使用nagle算法（setsockopt TCP_NODELAY设置，默认开启）。要等到窗口大小 >= `MSS` 并且 数据大小 >= `MSS`或者收到之前发送数据的 `ack` 回包才可以发送数据。实时性要求高不能使用nagle算法。
nagle算法和delay ack一起使用会出问题。
#### delayed ack

延迟ACK的目的也是为了减少网络中传输大量的小报文数，但该报文数是针对ACK报文的。
个来自发送端的报文到达接收端，TCP会延迟ACK的发送，希望应用程序会对刚刚收到的数据进行应答，这样就可以用新数据将ACK捎带过去。不止发送ack报文，而是改成ack+数据。 
延迟时间为200ms。
### 流量控制

定义：**可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。** 如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。
是发送方和接收方之间进行协调，两点之间。
### TCP拥塞控制

目的：流量控制避免「发送方」的数据填满「接收方」的缓存；拥塞控制是避免整个网络拥堵导致丢包时延等问题，是宏观上，整个网络中，防止丢包、时延。

如何判断是否拥塞：出现超时重传就认为网络拥塞。

四个算法：慢启动（指数增加，当 `cwnd` < `ssthresh` 时使用）、拥塞避免（当当 `cwnd` >= `ssthresh` 时使用，每次+1）、拥塞发生（发生重传时使用。两种重传：超时重传，快速重传 ；ssthresh = cwnd / 2, cwnd = 1）、快速恢复(cnwd = cwnd / 2, ssthresh = cnwd；)四个算法。
## 高阶问题

### 滑动窗口综合征、nagle、cork算法？

nagle解决小包造成的网络拥塞问题，所以网络不拥塞的话，还是要发送小包。
Cork算法就不允许小包发送，如果是小包，就只能等。Cork算法的目的跟Nagle不一样，Cork是解决网络利用率低的问题，小包当然利用率低，所以只发送大包，简单粗暴。默认关闭。

**滑动窗口综合征是什么？** 
# HTTP
## HTTP与HTTPS，HTTP1.1与HTTP2.0区别？

 - 安全性：HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- 连接：TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- 端口：HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。
    **HTTPS解决了HTTP的安全问题：解决窃听风险（混合加密）、篡改风险（摘要算法）、伪装风险（数字证书）**

HTTP2.0主要解决HTTP的性能问题。
- _队头阻塞问题_，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；---------**多个 Stream 复用一条 TCP 连接，达到并发的效果**。多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，HTTP 消息可以由多个 Frame 构成， 一个 Frame 可以由多个 TCP 报文构成。**不同stream可以乱序发送，同一stream的帧必须严格有序**
- _HTTP 头部巨大且重复_，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 Cookie 的头部，而 Cookie 的大小通常很大；--------头部压缩，哈夫曼算法，二进制编码，静态表，动态表（占内存）。
- _不支持服务器推送消息_，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。--------客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。
缺点：**HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。**
HTTP3.0直接使用udp

## GET和POST的区别？

- 语义：GET 的语义是从服务器获取指定的资源, POST 的语义是根据请求负荷（报文body）对指定的资源做出处理
- 参数：GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制；POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，且无大小限制。GET可以带body，POST url也可以有参数
- GET安全且幂等，可缓存；POST不安全、不幂等、不可缓存
- GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；**而对于POST，浏览器先发送header**，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
# 网络问题
## 输入网址到网页显示期间发生了什么？

- 1、浏览器解析URL并生产HTTP请求消息
- 2、DNS查询web服务器的IP地址
- 3、建立TCP连接（三次握手）
- 4、浏览器发送HTTP请求
- 5、服务器处理HTTP请求
- 6、浏览器解析HTML并渲染页面
- 7、断开TCP连接（四次挥手）
## 各种缩写：RTT、RTO、MSS、MSL、MTU？

RTT = 接收确认数据包的时间 - 发送数据包的时间 - 时延。tcp中使用
RTO：tcp超时重传时间。**超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**。
- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节；IP层超过MTU要分片
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；

# 网络编程

listen() ： 不阻塞，将socker可以接受连接并限制连接数
accept()：默认为阻塞，listen对应连接队列为空即阻塞。可以在`int socket(int domain, int type, int protocol);`设置type为SOCK_NONBLOCK来设置socketfd非阻塞

close()：是相应的socketfd引用计数-1，只有引用计数变为0，才会触发TCP客户端向服务端发送终止连接请求。