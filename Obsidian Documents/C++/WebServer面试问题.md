**为什么要做这样一个项目？**
	学习完cpp基础和linux系统编程网络编程后，需要一个项目来在实践巩固所学知识。这个项目很多人推荐，并且他的综合性很强。

**描述介绍一下你的项目？**

这个项目主要的目的是对浏览器的链接请求进行解析处理，处理完之后给浏览器客户端返回一个响应，如文字图片视频等。服务器后端的处理方式使用socket通信，利用epoll多路IO复用技术，可以实现服务器高并发同时处理多个请求，请求的解析使用预先准备好的线程池，使用模拟proactor模式，==异步主线程==负责监听，监听到有事件后，从socket中循环读取数据，然后将读取到的数据封装成一个请求对象插入请求队列中。睡眠在请求队列上的工作线程被唤醒进行数据读取以及逻辑处理。利用==正则表达式和有限状态机==思想解析 Http 报文，支持 GET/POST 请求，支持长/短连接（connection：keep-alive）；

使用==基于小根堆的定时器关闭超时请求==，解决超时，连接系统资源占用问题。
实现==同步异步日志==记录

>项目难点和亮点：

**难点**:
- 模拟proactor的实现
- 模块比较多，怎么综合这些模块

**亮点**：
- 采用了模拟proactor设计模式，引入了epoll I/O多路复用技术，采用ET模式
- 使用了线程池
- 基于双向升序链表实现了定时器
- 实现了可以自动增长的缓冲区（scatter read and gather write、io_vector）
- 单例模式实现同步和异步日志，双缓冲区解决日志输出和写入速度不匹配问题
- 有限状态机解析http请求报文

> **用到了哪些多线程库？**

pthread.h semaphore.h  shared_mutex
使用读写锁，将get post请求分成不同的队列。

# reactor非阻塞同步和proactor异步网络模式

## 为什么需要I/O多路复用

服务器服务多个线程->每个客户端一个线程->为减少频繁创建销毁线程的开销->使用线程池资源复用->read操作会阻塞线程导致线程浪费->不是连接上就分配线程，而是当有数据是在分配线程->IO多路复用。

## 产生

大佬们基于面向对象的思想，对 I/O 多路复用作了一层封装，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写。这就是Reactor。


## 组成

Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：

-   Reactor 负责监听和分发事件，事件类型包含连接事件（主线程完成）、读写事件；
-   处理资源池负责处理读写事件，如 read -> 业务逻辑 -> send；

## 多种实现方式



# select/poll/epoll

select/poll。分别使用BitMap和动态链表来维护一个已连接socket的文件描述符集合，然后将其拷贝到内核中，让内核遍历检查是否有事件发生，然后再从内核态将文件描述符集合拷贝回用户态，然后在用户态遍历查看可读写socket。这两个只能LT效率低。fd数量少，select为1024。
需要两次拷贝，两次遍历，两次上下文切换。
epoll。直接在内核中使用红黑树结构维护待检测的文件描述。内核使用一个链表维护就绪事件。当红黑树结构中有事件发生就会添加到链表中， 然后返回有事件发生的个数。
- 工作模式
- fd数量
- 数据结构
- 消耗和效率


同步io和异步io？

执行IO操作是否阻塞。IO多路复用是同步的。NIO是同步的。

僵尸进程和孤儿进程？

孤儿进程是指父进程死亡的进程，会交给pid为1的init进程，没有危害。
僵尸进程是指父进程并没有回收退出的子进程的资源，会消耗系统资源，可以使用kill命令来杀死父进程


GET/POST请求方法的区别？

GET只发送一次数据包，POST发送两次，先发送headers，服务器响应100 continue后再发送data。

# 流程：

**连接处理**

epollfd监听到listenfd上的连接事件后进行accept获取connfd，根据connfd创建http连接并将此connfd加入到epollfd，创建该连接的定时器。

![](Pasted%20image%2020230501001013.png)


**请求报文处理--有限状态机**

	此时如果该客户发出http请求（如点击网页按钮），那么就会触发该connfd的EPOLLIN，然后调用`webserver::dealwithread()`函数。该函数（模拟proactor模式）先调整该connfd的定时器，使用read_once()函数读取数据然后再加入线程池请求队列中（connfd， 0）进行业务逻辑处理。
	空闲线程会处理该请求，线程池的回调函数是worker函数，worker函数中调用run函数。run函数从请求队列中取出一个请求，从sql连接池中取出一个mysql连接然后进行`http_conn::process()`。先进行`process_read()`该函数使用主从状态机进行读取的请求报文的解析，最后扔入`do_request()`函数中
![](Pasted%20image%2020230430234631.png)
`do_request()`拼接处实际请求的本地文件目录，使用mmap映射到内存中。

**返回响应报文**

	`process_read()`之后使用`process_write()`书写响应报文，并将地址写入到m_iv中，预备发送报文。iovec第一个是写buffer的位置，第二个是文件映射到内存中的位置。
	最后在`process`函数中执行到`modfd`函数，注册写事件。之后模拟Proactor事件处理模式下，主线程重新进行这个过程检测到该connfd上的EPOLLOUT事件，然后调用`http_conn::write()`返回响应报文给浏览器。


**半同步/半反应堆模式是什么？同步和异步线程？**

	同步线程是子线程，负责处理客户逻辑。异步线程是主线程，负责处理IO（模拟Proactor）、连接事件。
	异步线程完成了IO操作后,如何选择同步线程即工作线程的方法有几种,第一种是工作线程通过抢占锁,一种是通过条件变量condition.notify_one操作,或者是Round robin方式(可以找代码看看),还有信号量(这个怎么做呢?)


**同步日志和异步日志的不同？怎么实现的？**


**异步日志阻塞队列采用的什么实现的？优缺点？**

	使用循环动态数组实现。缺点不易扩展，优点不会频繁的创建销毁。
	使用条件变量来唤醒睡眠在阻塞队列上的所有线程

>异步日志双缓冲区是什么？怎么实现的？为什么高效

准备两块 buffer: A 和 B;前端负责往 buffer A 填数据(日志信息)；后端负责把 buffer B 的数据写入文件。当 buffer A 写满之后，交换 A 和 B，让后端将 buffer A 的数据写入文件，而前端则往 buffer B 填入新的日志信息，如此反复。

**CGI**

	通用网关接口

**怎么解析的http请求报文**

	1. 有限状态机，有哪些状态机，状态转移是怎样的？
	2. 正则表达式。编写正则表达式。
![](Pasted%20image%2020230430234631.png)


**怎么进行的压力测试？原理是什么？**

	使用的webbench。
	原理：父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。

**还打算做哪些改进？添加什么功能？**

	定时器使用更高效的数据结构：时间轮、红黑树。
	功能：文件上传、摄像头调用。使用cookie、session完成状态保存。

**做项目中遇见了哪些难题？**

[最新版Web服务器项目详解 - 13 踩坑和面试题 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzAxNzU2MzcwMw==&mid=2649274431&idx=1&sn=2dd28c92f5d9704a57c001a3d2630b69&chksm=83ffb167b48838715810b27b8f8b9a576023ee5c08a8e5d91df5baf396732de51268d1bf2a4e&token=1686112912&lang=zh_CN#rd)
	1. 大文件传输
	2. c++pthread_create第三个参数必须是静态的，如何调用动态成员？

**主线程如何通知子线程有任务？**

**主线程如何选择子线程，怎么负载均衡？**

	round robin轮询。

**讲讲小根堆定时器的实现？**

**自动增长的缓存区怎么实现的？**
https://blog.csdn.net/ccw_922/article/details/124635799

**定时器为什么使用双向链表，单向链表不行吗？**

	- 因为单向链表删除的时候需要遍历找到其前驱，然后再进行删除操作；双向链表直接进行删除操作，因为其保存着前驱指针prev。这样在如果某个连接断开，拿出http连接的定时器，进行删除的时候时间是O(1)的。
	- 可以直接使用push_front在头部进行插入。

**如何提高性能，提高并发量？**

	- 动静态分离
	- 使用分布式服务器，并使用负载均衡技术
	- 使用缓存，进行页面压缩
	- 数据库进行优化，分表分库，读写分离，索引优化

>**几个信号的处理？**

SIGPIPE：

>proactor和reactor的区别

Reactor是在事件发生时就通知事先注册的事件（读写由处理函数完成）；Proactor是在事件发生时进行异步I/O（读写由OS完成），待IO完成事件分离器才调度处理器来处理。



