MVCC不止是一种CC手段
无锁

# 课程内容

![](Pasted%20image%2020230526184250.png)

# 并发控制协议

MVCC单独做不到serialable的级别，因此经常和其他并发控制手段结合使用完成CC。

- 与T/O结合
- 与OCC结合
- 与2PL结合

![](Pasted%20image%2020230526184359.png)

# 版本存储

![](Pasted%20image%2020230526184445.png)
用元组指针，建立一个版本链表。索引指向这个链表的头

## 存储手段

![](Pasted%20image%2020230526184547.png)

### append-only

![](Pasted%20image%2020230526184644.png)
直接加到表中，然后链表指向。

#### 两种方式

![](Pasted%20image%2020230526184715.png)

### time-travel

主表存最新版本的所有数据，历史版本放到一个时间遍历表中。
![](Pasted%20image%2020230526184856.png)

### delta storage

time-travel方式的优化
历史版本表中只存变化。叫dleta storage segment。
通过恢复得到历史版本。
![](Pasted%20image%2020230526185053.png)
mysql使用这个 undo segment。

# 垃圾回收

![](Pasted%20image%2020230526185220.png)
哪些版本可回收？
- 没有活跃事务能看到这个版本
- 这个版本是abort事务创建的。

实现考虑的问题？
- 怎么发现这些过期版本？
- 时候时候删除过期版本？

## 实现思路

![](Pasted%20image%2020230526185454.png)
- 直接根据元组层面来找发现过期版本，有两种实现方法。
- 事务层面，以事务为单位回收

### tuple level GC

#### 后台清理

一个专用的后台线程来做回收
![](Pasted%20image%2020230526185903.png)
可以标记脏页，使后台吸尘器无需扫面整张表

#### 合作清理

![](Pasted%20image%2020230526190046.png)
工作线程顺带清理

### transaction-level GC

![](Pasted%20image%2020230526190112.png)
![](Pasted%20image%2020230526190253.png)

# 索引管理

多版本情况下的索引管理
主键索引指向版本链表头。
![](Pasted%20image%2020230526190552.png)
辅助索引比较麻烦

## 辅助索引

![](Pasted%20image%2020230526191008.png)
1. 存储逻辑地址。pk值或者rid，然后进行回表。
2. 同主键索引也记录tuple物理地址。

![](Pasted%20image%2020230526191204.png)
辅助索引可能有多个，如果是指向物理地址，那么版本更新时多个都要改变
![](Pasted%20image%2020230526191255.png)
可以建立一个临时表，来减少该表
![](Pasted%20image%2020230526234858.png)
辅助索引，如果指向主键，那么不用改变。
![](Pasted%20image%2020230526191339.png)

MVCC可能有重复键
![](Pasted%20image%2020230526234944.png)
![](Pasted%20image%2020230526235156.png)
![](Pasted%20image%2020230526235220.png)



# MVCC删除

![](Pasted%20image%2020230526235319.png)
![](Pasted%20image%2020230526235437.png)


![](Pasted%20image%2020230526235602.png)


# 总结

![](Pasted%20image%2020230526235723.png)
