> 需求

![](Pasted%20image%2020230527152920.png)

![](Pasted%20image%2020230527153116.png)
这节研究在执行事务时数据库要多做哪些工作。

# 课程内容

![](Pasted%20image%2020230527153238.png)

# 故障类别



![](Pasted%20image%2020230527153330.png)

>思考

![](Pasted%20image%2020230527154206.png)
![](Pasted%20image%2020230527154217.png)






# 缓冲池策略

![](Pasted%20image%2020230527172710.png)
刷脏页策略：
- 窃取式：刷这个页中的所有数据，包括其他事务的数据
- 非窃取式：开一个新页
commit之后是否要立马刷脏
![](Pasted%20image%2020230527172736.png)

![](Pasted%20image%2020230527172857.png)
优点：无需undo redo
缺点：输出到磁盘是块为单位，但日志往往远小于块，开销大。
![](Pasted%20image%2020230527172945.png)

# 影子页恢复技术

![](Pasted%20image%2020230527174746.png)
![](Pasted%20image%2020230527174834.png)
![](Pasted%20image%2020230527175005.png)
![](Pasted%20image%2020230527175111.png)

## 缺点

![](Pasted%20image%2020230527175237.png)
- copy整个页开销大。
- commit的瞬间开销太大。
- 需要垃圾清理
- 容易数据碎片化，产生碎片

一般都是用的改进版shadow paging，比如sqllite

>思考

![](Pasted%20image%2020230527190025.png)
有大量随机读写。

为解决上述问题，提出WAL。

# WAL

先写日志。
日志缓存区。
在刷脏页前，先刷日志缓存。
![](Pasted%20image%2020230527190405.png)

## 方法介绍

![](Pasted%20image%2020230527190508.png)

## 实例

![](Pasted%20image%2020230527191112.png)
数据库来决定什么时候刷数据。

## 实现

![](Pasted%20image%2020230527194107.png)

### 优化： group commit

![](Pasted%20image%2020230527191641.png)

### 刷脏

性能分析
![](Pasted%20image%2020230527195415.png)

# 日志类型

![](Pasted%20image%2020230527202522.png)
![](Pasted%20image%2020230527203127.png)
改进
![](Pasted%20image%2020230527203413.png)
![](Pasted%20image%2020230527203946.png)
