# 课程内容

数据库并发控制的实现

![](Pasted%20image%2020230525210600.png)

前面的我们都是在commit之后进行分析，马后炮。
![](Pasted%20image%2020230525210805.png)
![](Pasted%20image%2020230525210926.png)


## 今日任务

![](Pasted%20image%2020230525210946.png)


![](Pasted%20image%2020230525211003.png)
lock是宏观的，锁的是表、行。
latch锁的是b+树

# LOCK TYPE

![](Pasted%20image%2020230525211141.png)
共享锁，排他锁。也就是读写锁。

![](Pasted%20image%2020230525211227.png)

问题：
![](Pasted%20image%2020230525211403.png)
这里虽然加了锁，但是仍然出现了不可重复读问题。


# 2PL

目的：解决不可重复读问题
核心思想：==如果一个transaction释放了它持有的任意一个锁，那它再也不能获取锁==

![](Pasted%20image%2020230525211511.png)
执行过程中避免了冲突。

## 步骤

![](Pasted%20image%2020230525211556.png)
**每个事务加解锁遵守两个阶段**：
- growing：不断枷锁，只能枷锁
- shrinking：收缩阶段，只能解锁，不能枷锁。

![](Pasted%20image%2020230525211640.png)

![](Pasted%20image%2020230525211838.png)
解决了之前的不可重复读问题。

![](Pasted%20image%2020230525211917.png)
产生的依赖图没有环。

## 问题

但是会有级联回滚问题，也会由脏读问题（读未提交），如下图。
![](Pasted%20image%2020230525212215.png)
T1回滚了T2也得回滚。

还有两个问题即其解决办法：
![](Pasted%20image%2020230525212759.png)

### 解决

#### 脏读

==使用严格二阶段锁：只允许事务最后（commit/abort）解锁。==

![](Pasted%20image%2020230525212828.png)
只有commit或者abort的时候可以解锁。
![](Pasted%20image%2020230525212923.png)
解决了级联回滚和脏读。只能自己这个事务来操作这个数据。

##### 举例

![](Pasted%20image%2020230525233733.png)
不使用二阶段锁
![](Pasted%20image%2020230525233759.png)
产生了不一致情况

使用二阶段锁
![](Pasted%20image%2020230525233959.png)

严格二阶段锁
![](Pasted%20image%2020230525234047.png)


![](Pasted%20image%2020230525234257.png)


#### 2PL死锁

![](Pasted%20image%2020230525234335.png)

死锁的四个必要条件？
![](Pasted%20image%2020230525234524.png)
强严格二阶段锁无法解决死锁问题。

![](Pasted%20image%2020230525234648.png)
解决方法：
1. 死锁检测
2. 死锁预防

##### 死锁检测

mysql是这种。

![](Pasted%20image%2020230525234726.png)
dbms维护一个waits-for图来追踪事务等待锁：
- 节点是事务
- 有向边代表等待释放锁。
如果成环就产生了死锁。
![](Pasted%20image%2020230526000701.png)

![](Pasted%20image%2020230526000740.png)
检测到死锁，选择一个victim事务来回滚解除环。或者重启或者abort
要权衡检测死锁的频率

###### 选择victim

如何选择victim？考虑因素？
![](Pasted%20image%2020230526001046.png)

###### 如何回滚victim

![](Pasted%20image%2020230526001211.png)
1. 全部回滚
2. 回滚死锁的sql语句
##### 死锁预防

![](Pasted%20image%2020230526001250.png)

![](Pasted%20image%2020230526003609.png)
根据时间戳给优先级。老事务具有高优先级。

两种方法：
- 优先级高的可以等待优先级低的，反过来优先级低的直接abort。
- 优先级高的直接抢夺优先级低的锁，并且优先级低的abort，反过来优先级低的等待。
![](Pasted%20image%2020230526004036.png)

![](Pasted%20image%2020230526004228.png)
为避免饥饿，重启的事务具有第一次begin的时间戳，即高优先级。

>思考

![](Pasted%20image%2020230526005004.png)
前面讲的锁的粒度都是行锁。lock开销比latch大很多

# 锁粒度

![](Pasted%20image%2020230526005154.png)

列锁、行锁、页锁、表锁。
在加锁开销和并发性之间做权衡。
![](Pasted%20image%2020230526005420.png)
# 意向锁

快速判断是否可以进行加锁？
使用意向锁。
![](Pasted%20image%2020230526005610.png)
意向锁允许更高层级的节点无需检查所有低层节点直接加锁。类似于一个标记。

如表加了意向锁，那么不可以对其加锁，代表着他下面的有的行、列已经被锁住了。

## 意向锁种类

![](Pasted%20image%2020230526005913.png)
==意向锁代表本层没锁，低层次有锁==
SIX：低层次有排他锁，本层又加了共享锁。

锁矩阵
![](Pasted%20image%2020230526010145.png)
![](Pasted%20image%2020230526010309.png)
先对上层加意向锁，才能对本层进行加锁。
![](Pasted%20image%2020230526010512.png)
![](Pasted%20image%2020230526010549.png)
第二个例子
![](Pasted%20image%2020230526010618.png)
![](Pasted%20image%2020230526010741.png)
![](Pasted%20image%2020230526010825.png)
![](Pasted%20image%2020230526010852.png)
T3被T1的IX锁卡住，需要等待。
![](Pasted%20image%2020230526010931.png)


![](Pasted%20image%2020230526011005.png)

## 锁提升

![](Pasted%20image%2020230526011115.png)

# 实践中的锁

![](Pasted%20image%2020230526011231.png)
绝大多数是数据库加锁
![](Pasted%20image%2020230526011335.png)
![](Pasted%20image%2020230526011351.png)
显示告诉dbms加x锁或者s锁。

# 总结

![](Pasted%20image%2020230526011515.png)
