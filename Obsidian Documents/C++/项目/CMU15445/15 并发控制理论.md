事务！
--------第二难的部分

# 本节课内容

==事务==

架构图
![](Pasted%20image%2020230525164441.png)
两块功能图中没有展示
- 并发控制
- 恢复
![](Pasted%20image%2020230525164518.png)

# 需求

避免竞态。
![](Pasted%20image%2020230525164634.png)

![](Pasted%20image%2020230525164708.png)

# 事务

调度：

![](Pasted%20image%2020230525165023.png)
事务是数据库操作的最小单位。由一个或者多个SQL语句组成。
![](Pasted%20image%2020230525165109.png)

## 原子性

要么全部执行，要么全部不执行（将已经执行的撤销）

### 不成熟实现思路

![](Pasted%20image%2020230525165528.png)
串行执行txn。
先备份整个数据库到新文件，然后再将改变写入。
- txn成功执行，重写源文件
- 执行失败，丢弃修改的脏文件。

#### 问题

无法并发
![](Pasted%20image%2020230525170157.png)

任意运行会产生两种问题：
![](Pasted%20image%2020230525170211.png)


![](Pasted%20image%2020230525170401.png)

数据就是一系列固定的数字，不关心具体代表什么。事务就是一系列读写操作。
![](Pasted%20image%2020230525170454.png)

SQL语句怎么操作事务。
![](Pasted%20image%2020230525170712.png)

## ACID特性

![](Pasted%20image%2020230525170928.png)
- 一致性：事务发生前后状态要一致。正确性。
- 持久性：事务提交后，影响是永久的。出现故障提交的也不能丢

## 原子性

**![](Pasted%20image%2020230525172339.png)

![](Pasted%20image%2020230525172438.png)

### 实现方法

1. undo日志。大部分DBMS用这个
2. shadow paging

![](Pasted%20image%2020230525172525.png)
日志除了回滚其他作用：
- 追踪做了什么
- 提高效率
![](Pasted%20image%2020230525172852.png)
不成熟思路的改进，只改进修改的页。


## 一致性

![](Pasted%20image%2020230525172942.png)
符合逻辑结果。分为两种：数据库一致性和事务一致性。
逻辑一致性
时间一致性：后面发生的事务，可以看到前面事务的结果。


![](Pasted%20image%2020230525173114.png)
事务一致性。用户sql语句来保证。

## 隔离性

![](Pasted%20image%2020230525173525.png)

### 实现方法

1. 悲观锁
2. 乐观锁：假设冲突很少。

![](Pasted%20image%2020230525173623.png)

#### 举例

![](Pasted%20image%2020230525173822.png)
![](Pasted%20image%2020230525173839.png)
一致性要求最终ab的和是2120.
不能要求T1T2的顺序。
![](Pasted%20image%2020230525173952.png)
串行执行的情况。
![](Pasted%20image%2020230525174123.png)

并发执行的情况。

为什么需要并发执行
![](Pasted%20image%2020230525174158.png)
![](Pasted%20image%2020230525174347.png)
出现问题的串行情况（一致性问题）
![](Pasted%20image%2020230525174426.png)

底层数据库是怎么看这些事务操作的？
![](Pasted%20image%2020230525174540.png)
后面从数据库视角分析问题。为什么第二种顺序不对？

如何判断正确性？
![](Pasted%20image%2020230525174736.png)

### 几种操作序列类型

![](Pasted%20image%2020230525174753.png)
![](Pasted%20image%2020230525174915.png)
第三种可以转换成第一种计划。第一种是理想的，影响性能。要用可串行的。
第二种结果相同即可。
![](Pasted%20image%2020230525175105.png)

### 隔离性的冲突操作（几种隔离级别）

==不同冲突产生了不同隔离级别。==

不产生冲突的操作可以交换顺序。然后来看是否等效操作序列

![](Pasted%20image%2020230525175307.png)
冲突操作：
- 来自不同事务。
- 在操作同一个数据而且至少一个是写。即RR没冲突
![](Pasted%20image%2020230525175433.png)

#### 读写（读）冲突

==不可重复读：在一个事务中，对一个数据重复读，其结果应该是一样的。==
没有保证隔离性。

![](Pasted%20image%2020230525175445.png)

#### 写读冲突

读未提交（脏读）
![](Pasted%20image%2020230525175842.png)

#### 写写冲突

![](Pasted%20image%2020230525180035.png)
理论上应该留下T1的结果或者T2的结果，但是现在两个事务都保存了一部分结果。

![](Pasted%20image%2020230525180240.png)
根据冲突我们可以理解什么是可串行化，即不产生这些冲突问题。

等效可串行化两个种类：
- 冲突可串行化：大部分支持
- 观察可串行化：没有dbms支持，比较难实现。

### 冲突可串行化序列

如果两个**连续操作不冲突**，则可以在调度中交换顺序。必须连续且不冲突才可以交换次序。
**一个调度S在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度S’，如果S’是串行的，称调度S为冲突可串行化的调度。**
==进行无冲突操作交换==后可以变成串行序列。

![](Pasted%20image%2020230525180501.png)
冲突等效：
- 两种序列事务相同且产生的冲突一样。

![](Pasted%20image%2020230525180622.png)
一个序列在进行可交换无冲突操作后等于串行的。无冲突可以交换位置
![](Pasted%20image%2020230525181004.png)

### 多个事务序列冲突可串行化

多个事务交换用什么算法？
![](Pasted%20image%2020230525181257.png)

#### 算法：依赖图

![](Pasted%20image%2020230525181413.png)
==一组操作序列是冲突可串行化的当且仅当依赖图无环==
- 有向边代表事务1的操作和事务2的操作有冲突。三种

![](Pasted%20image%2020230525181905.png)

![](Pasted%20image%2020230525181950.png)
拓扑排序找可以转化为串行的执行顺序。实际在并发跑，但是可以跟串行执行效果等效。

![](Pasted%20image%2020230525191733.png)
![](Pasted%20image%2020230525191749.png)
有些操作也是可以串行化的

### 观察可串行化

![](Pasted%20image%2020230525191957.png)
![](Pasted%20image%2020230525192020.png)
虽然有环但实际上是可串行化的。
![](Pasted%20image%2020230525192108.png)
这种没法编程实现。只能人来观察。

![](Pasted%20image%2020230525192223.png)
也可以其他优化：如忽略只读事务

![](Pasted%20image%2020230525192448.png)

## 持久性

![](Pasted%20image%2020230525192530.png)
同原子性使用log 或者shadow paging来保证。


# 总结

![](Pasted%20image%2020230525192622.png)

![](Pasted%20image%2020230525192903.png)
