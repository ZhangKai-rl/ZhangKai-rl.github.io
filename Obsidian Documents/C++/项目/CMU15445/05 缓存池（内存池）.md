# 解决问题

数据存储在磁盘上，但是对数据进行读写需要先放在内存中。磁盘中的数据加载到内存中和内存中的写回磁盘。

缓存磁盘上的数据库页
修改的数据先在内存中并不是直接写回到磁盘，而是集中写。
![](Pasted%20image%2020230319154747.png)
基于两个局部性原理

# 本节课任务：
![](Pasted%20image%2020230319161328.png)
管理器、替换策略、除缓存数据页之外的其他内存池

# 缓存池管理器

![](Pasted%20image%2020230319161531.png)

### 页表
![](Pasted%20image%2020230319162417.png)
磁盘中叫页，内存中叫页帧。栈的一行记录也叫栈帧。页表类似于虚存物存的页表。
缓存池一个帧就是一个page的slot，用来存储磁盘中的页。因此需要一个页表，执行引擎请求页时，页表将其转换成frame id，然后再缓存池中根据frame id取出指定页。页表中还存储元数据
(lab1中元数据存储在Page内)

#### 锁
 ![](Pasted%20image%2020230319163140.png)
 辨析了lock、latch两种锁的不同。还有mutex
lock：高级的，逻辑上的比如锁某张表。是抽象的
latch：是底层的、具体的。lock时底层用到latch。是具体的锁。有时也叫mutex

#### 页表和页目录

这里的页目录是对文件组织方式中的页目录方式
![](Pasted%20image%2020230319163626.png)
![](Pasted%20image%2020230319163527.png)
页目录：将页id映射到磁盘中页位置。记录某一页的位置。存储在磁盘上

![](Pasted%20image%2020230319163550.png)
页表：页id映射到缓存池。在内存中，无需存到disk

缓存池页放置策略
![](Pasted%20image%2020230319163929.png)
分为全局策略和本地策略

## 缓存池优化策略

提高缓存池性能
![](Pasted%20image%2020230319164110.png)

### 1. 多缓存池

![](Pasted%20image%2020230319164148.png)
有专门存元数据的缓存池，存数据的缓存池，存索引的缓存池。
降低了latch冲突（锁竞争）
![](Pasted%20image%2020230319164416.png)
多缓存池实现的两种方式：
	*  插入一个objectid记录放到了哪个缓存池
	*  使用哈希，来放到某个缓存池

### 2. 预取

![](Pasted%20image%2020230319164650.png)
类似于空间局部性原理
下图是index-scan
这也是为什么DBMS要自己管理内存的原因。
![](Pasted%20image%2020230319164848.png)

### 3. 共享扫描
![](Pasted%20image%2020230319165323.png)
两个sql语句读同一个表，可以同步扫描。
result catching：事务A执行了结果后，B执行时直接拿取这个结果。
![](Pasted%20image%2020230319165513.png)
![](Pasted%20image%2020230319165640.png)
在1处理到p3时，2到达。直接将c2绑定到c1，一起扫描到p5后，c2在重新扫描p0p1p2。

### 4. 缓存池旁路（不进内存池）

![](Pasted%20image%2020230319165932.png)
使用只用一次的数据

### 与OS缓存的关联
![](Pasted%20image%2020230319170057.png)
绕过os缓存，os不知道数据库怎么使用数据。
使用O_DIRECT减少了os缓存的冗余

#  缓存替换策略

![](Pasted%20image%2020230319170302.png)

- LRU
- CLOCK

![](Pasted%20image%2020230319170406.png)
设置一个访问时间戳，开销较大。
![](Pasted%20image%2020230319185641.png)
设置一个访问位，一个始终指针。发现1清零，发现0直接换出。快速LRU

## 策略的问题

LRU在数据库中的问题：
![](Pasted%20image%2020230319190812.png)
顺序读时都没有用
![](Pasted%20image%2020230319191233.png)
## 改进策略

- LRU-K：最近k次使用
- LOCALIZATION（局部策略）：清理本事务用过的，不同访问采用不同的内存池
- 优先级提示
![](Pasted%20image%2020230319193252.png)
执行器给缓存池一些指示

## 脏页问题

内存写回磁盘
脏页
![](Pasted%20image%2020230319193504.png)
脏页必须写回磁盘。一般是集中写回
如果修改完断电了怎么办？有日志，页可以先不写进去，但是日志要先写进去。这对于数据一致性和rollback和重要
![](Pasted%20image%2020230319194149.png)
刷脏：将内存中修改的页集中写回磁盘

# other memory pools

除了缓存磁盘上的数据索引的池。

![](Pasted%20image%2020230319194348.png)
query caches ：执行结果的缓存

# conclusion

![](Pasted%20image%2020230319194657.png)
