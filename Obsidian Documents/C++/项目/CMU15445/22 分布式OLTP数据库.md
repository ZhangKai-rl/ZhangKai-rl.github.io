# 上节课内容

![](Pasted%20image%2020230601231255.png)

![](Pasted%20image%2020230601231351.png)

>思考

![](Pasted%20image%2020230601231537.png)
- 如果主节点询问时有节点不同意？
- 节点信息传输慢？
- 如果不等待节点同意就提交？

研究分布式TP数据库的一个重要假设：
![](Pasted%20image%2020230601231716.png)
假设数据库软件没问题。可以很好的管理节点。
如果有些节点被黑客修改了，不能相信该节点，这种问题叫拜占庭问题，需要使用共识机制。不考虑这种情况。

# 本节课内容

![](Pasted%20image%2020230601232106.png)

# 原子提交协议（做事务协调）

![](Pasted%20image%2020230601232230.png)
用的最多的是2PC。

## 2PC两阶段提交

成功：
![](Pasted%20image%2020230601232847.png)
回滚：
![](Pasted%20image%2020230601233852.png)

### 优化

![](Pasted%20image%2020230601233915.png)
- 在最后一个sql指令的时候，直接带上commit，发起投票
- prepare阶段收到所有节点的确认后，直接提交（回复success）。

![](Pasted%20image%2020230601234134.png)

### 其他问题

为了引出paxos
![](Pasted%20image%2020230601234311.png)

## PAXOS

是一种共识机制。投票
![](Pasted%20image%2020230601234418.png)
大多数同意了就执行，少部分也要执行。

![](Pasted%20image%2020230602002646.png)
等node3恢复后
![](Pasted%20image%2020230602002715.png)



![](Pasted%20image%2020230602002907.png)


![](Pasted%20image%2020230602002940.png)
选举出单一leader，可以跳过propose阶段

## 比较

![](Pasted%20image%2020230602003106.png)

# 副本

![](Pasted%20image%2020230602003210.png)
数据放在多个节点上，防止一个节点挂。增加可用性。

## 副本架构/设置

![](Pasted%20image%2020230602003331.png)
- 主从复制：主节点操作数据，以某些形式分发给从节点，从节点做只读操作。主节点挂了，选个从节点当主节点，保证可用性。用的最多。
- 多个主节点：需要多主节点强制同步。
![](Pasted%20image%2020230602003930.png)

### K-安全

挂掉多少个对外拒绝服务。
至少要几个没挂。
![](Pasted%20image%2020230602004033.png)
最少k个可用副本。少于k数据库下线。

## 主从同步/更新副本

![](Pasted%20image%2020230602004107.png)
- 强一致性
- 最终一致性

### 同步/强一致性

主节点修改数据后，等待从节点也执行更新完成后才告诉用户提交成功。一般传输的是log。
慢。

### 异步/最终一致性

主库在本地提交后，就告诉用户提交成功。在后台异步将日志传输给从库。
安全性差。

![](Pasted%20image%2020230602004806.png)

### 半同步方案

等日志传送到从库，但是不等待从库执行完就告诉用户提交成功（mysql使用）

## 主从数据传播时机

![](Pasted%20image%2020230602005024.png)
- 持续不断传播：但是可能出现回滚
- commit时传播：不会有从跟着主回滚的问题。提交时传播有时间开销。日志长要暂存在主库里面，不能删除。

## 更新方法

![](Pasted%20image%2020230602005216.png)
- 传播的是SQL语句（逻辑日志）。要重新走解析优化执行
- 传播物理日志。对哪个页哪个槽进行了修改，效率高。可能会非常大

# 一致性问题（CAP）

![](Pasted%20image%2020230602005658.png)
一致性、高可用和网络分区容忍无法同时实现，只能最多两个。

C：线性一致性
A：可用性。一个节点挂掉后是否可以继续提供服务。保证一定能提供数据。
P：分区容忍性。网络不可靠，丢失消息后，系统仍可以提供服务。
![](Pasted%20image%2020230602010204.png)

## C

![](Pasted%20image%2020230602010358.png)
得到的都是最新的数据。

## A

![](Pasted%20image%2020230602010449.png)

## P

网络挂掉了。从库认为主库挂了。一个集群变两个集群。
牺牲了一致性，达成了可用性

![](Pasted%20image%2020230602010616.png)
右边由replica变成了primary
网络再次可达后。
![](Pasted%20image%2020230602010649.png)

## CAP for OLTP

![](Pasted%20image%2020230602010757.png)
- 传统数据库：一部分节点挂了，达到一个阈值一下，整个数据库下线。牺牲了可用性来保证一致性和分区容错性。
- NoSQL：

>思考

![](Pasted%20image%2020230602010944.png)
之前假设的都是在同一DBMS上，如果运行了mysql和pg上？
需要一个统一的接口。

# 联邦数据库

不同的数据库组到一个数据库集群里面。
![](Pasted%20image%2020230602011103.png)

![](Pasted%20image%2020230602011151.png)
pg可以作为一个中间件。

# 总结

![](Pasted%20image%2020230602011440.png)
以上学习，都是基于分布式中的节点都是可信任的。