# SQL语言分类

- DQL、DML、DDL、DCL

**1. 数据查询语言DQL**  
数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：SELECT <字段名表>FROM <表或视图名>WHERE <查询条件>

**2 .数据操纵语言DML**  
数据操纵语言DML主要有三种形式：  
1) 插入：INSERT  
2) 更新：UPDATE  
3) 删除：DELETE

**3. 数据定义语言DDL**  
数据定义语言DDL用来创建数据库中的各种对象-----表、视图、索引、同义词、聚簇等如：CREATE TABLE / VIEW / INDEX / SYN / CLUSTER| 表 视图 索引 同义词 簇。DDL操作是隐性提交的！不能rollback

**4. 数据控制语言DCL**  
数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：  
1) GRANT：授权。  
2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚---ROLLBACK回滚命令使数据库状态回到上次最后提交的状态。其格式为：SQL>ROLLBACK;  
3) COMMIT [WORK]：提交。在数据库的插入、删除和修改操作时，只有当事务在提交到数据库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看到所做的事情，别人只有在最后提交完成后才可以看到。提交数据有三种类型：显式提交、隐式提交及自动提交。下面分别说明这三种类型。

(1) 显式提交  
用COMMIT命令直接完成的提交为显式提交。其格式为：SQL>COMMIT；

(2) 隐式提交  
用SQL命令间接完成的提交为隐式提交。这些命令是：ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。

(3) 自动提交  
若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，系统将自动进行提交，这就是自动提交。其格式为：SQL>SET AUTOCOMMIT ON；

# 本课程主题

基于传统的关系型数据库，面向磁盘的。
包含以下四个主题内容：
- 存储
- 执行
- 并发控制
- 回复

# 存储引擎

数据库都是以文件的形式存储的。分成不同的块/页，第一页是目录。
内存中有缓存池（buffer pool）用来加载数据库文件。buff pool是内存中的一部分，其中有数据库页。

shim层？

课程讲解内容分布
![](Pasted%20image%2020230309141719.png)

## 为什么不使用OS

os中有mmap，这是一种实现虚拟内存的方法。
OS可以进行换页，但是OS不知道db的负载是怎样的，盲目换页会出现问题。
如果数据库只需要读取可以使用mmap，但是写的话os不知道哪些是脏页哪些被pin，并发控制
![](Pasted%20image%2020230309142323.png)
![](Pasted%20image%2020230519161454.png)
让DBMS自己管理page更加高效安全：
- 将脏页按照正确顺序刷新到disk
- 专门的预取规则
- 缓冲区替换策略
- 线程与进程的调度


## 两大问题

![](Pasted%20image%2020230309143611.png)
1. DBMS怎么在磁盘上表示数据库文件：页。一个page是固定大小的block（512B-4kb），可以包含元组、元数据、索引、日志记录等。存储引擎将会跟踪我们在这些page上所有的读写操作，以及跟踪每个page中还有多少空间允许存储新的数据。有些系统会要求它是自包含的，这意味着阅读每个page所需的所有信息都记录在page上，这使得page出错时能尽可能容灾恢复。
	大多数DBMS中，一个page只存储一种类型的数据，例如只存储tuple，只存储索引等。因此，每个page都会被赋予⼀个唯⼀的内部标识符，系统会生成属于page的ID。之后，就会有一个indirection层，这是在讨论存储时会被反复提及的内容。indirection层允许将⼀个page ID映射到某个物理位置，即某个文件中的某个位置（类似于一个字典映射，其实就是记录⼀个相对位置，方便文件整体移动后，只要知道整体文件的初始位置，我依然可以通过该相对位置（即page ID）找到某个文件某个位置的数据所对应的page）。这样的话，就可以支持磁盘的压缩或者使用另一块磁盘而不改变page ID。
1. DBMS怎么管理内存和进行置换页的。

## 03 存储引擎1

![](Pasted%20image%2020230309143758.png)

要提高页面的空间和时间局部性

### file storage文件存储结构---文件页

用页page来存储文件。

DBMS管理磁盘文件页的方式。文件组织结构

![](Pasted%20image%2020230309144144.png)

每个页存什么类型都是固定的
要区分数据库页和内存页，不是一个东西但功能类似。

indirection层map pid到物理位置。（==类似于我实现的可扩展哈希表？==）

常见数据库页大小（4-16KB）
![](Pasted%20image%2020230309144636.png)

#### 文件页组织方式：堆文件

堆文件是无序的页的集合，页内也非有序。
![](Pasted%20image%2020230309144904.png)
必须支持增删改查页，遍历页
关系型数据库行无序，列无序存储


==堆中页的组织形式：==
	- 链表
	- 页目录
![](Pasted%20image%2020230309145114.png)

##### 链表堆文件组织方式

链表组织：文件开头需要一个头页，存储两个指针分别指向空闲链表和数据链表。每个页都要存储现在有多少个空闲slot
![](Pasted%20image%2020230309145319.png)
文件开头都有个头页，其中有两个指针，分别指向空页链表和数据链表

##### 页目录堆文件组织方式

页目录（其中有目录项）：告诉执行引擎数据在哪张页上
![](Pasted%20image%2020230309145411.png)
有个页目录，其中包含数据库文件中页的位置和每个页的空槽数

### page layout页内数据组织方式

一个页内部的组织结构

![](Pasted%20image%2020230309145653.png)
页头包含元数据：页大小、校验和、版本、是否枷锁并发相关、是否压缩

==页内数据存储两种方式：==
- 面向元组
- 日志结构
![](Pasted%20image%2020230309150040.png)

 #### 页内数据组织方式：面向元组型

![](Pasted%20image%2020230519162943.png)

##### 页内数据组织方式：槽页

这种是朴素做法
![](Pasted%20image%2020230309150420.png)
这种页组织结构更常用。
槽中存储具体元组的索引，slot是顺序的，tuple不一定是顺序的。
一种将特定slot映射到page某个特定偏移量上的数据结构，这样一个元组就是由一个page id和slot id来唯一定位，并且tuple是倒序存储的。


### 唯一元组标识

- RID
- pageid + slot id 更为常用

![](Pasted%20image%2020230309150632.png)
用于数据库内部。使用来表示唯一的tuple。每个tuple使用RID来唯一标识

### tuple layout元组内组织方式

元组结构。一条条数据是怎么组织的。
tuple基本就是一行数据

tuple是二进制序列。
![](Pasted%20image%2020230309150826.png)
是否被锁了？ 并发控制。  ==tuple存时没有任何分割符因此头中用位图来表示NULL。==
不需要在头中存数据结构（页头需要存）

元组头和元组数据

数据
按照建表的顺序存

## 04 存储引擎2

### 页内数据组织方式：日志结构型

==比如说leveldb、bitcask、HBase就属于这种类型==
只允许附加到文件和删除过时的文件，但是不会更新已经写入的数据。

![](Pasted%20image%2020230310144312.png)
有的页中存的是数据操作日志，不存数据本身。
读日志是从后往前读
会周期性的压缩日志（相同id的操作最终合并）。允许为日志建立索引
方便回滚。是顺序读写，比随机读写效率高。
![](Pasted%20image%2020230318192851.png)
也可以通用压缩不分层

好处：将随机的写变成连续的写，操作时不找实际的磁盘页，而是新建页来记录这些操作，最后统一写。

本课程主要讲面向元组的页组织方式

### data representation

数据如何表示及表示如何被存储在每个page中。

从宏观的角度来看，一个元组实际上就是一段字节的序列或者说byte的数组，DBMS的任务就是将那些bytes翻译成有意义的属性值。DBMS的catalogs中包含着数据表的schema和元组的layout（类似数据表的说明书）。

数据类型存储方式
![](Pasted%20image%2020230318193934.png)

c++ float长度长了可能不精确了，浮点数不精确。
数据库利用字符串
![](Pasted%20image%2020230318194940.png)
小数点前位数，后位数，长度，符号，指针。

> LARGE VALUES(长数据)
1. 溢出页
![](Pasted%20image%2020230318195324.png)
大多数数据库不允许tuple超过单页长度。
新开一个overflow page，使用指针指向。如果还放不下就在用个指针指向新开的溢出页。
2. 外部文件
![](Pasted%20image%2020230318195547.png)

> SYSTEM CATALOGS

DBMS将数据库元数据存储在catalog中。
![](Pasted%20image%2020230318195705.png)
这个区域用来存储以上三种
数据库将自己的元数据也当成一张表
如：information_schema，存储表结构、innodb、优化器等。

### DATABASE WORKLOADS

![](Pasted%20image%2020230318200704.png)
OLTP：高并发，数据量小，用户用
OLAP：公司用，进行统计，复杂sql数据都大量数据
![](Pasted%20image%2020230318200935.png)

BIFURCATED ENVIRONMENT

解决上述问题，使用分叉环境
![](Pasted%20image%2020230318201347.png)
![](Pasted%20image%2020230318201429.png)

> OBSERVATION
![](Pasted%20image%2020230318201645.png)
关系模型没有要求数据库底层的存储方式，没要求必须一行一行存。

举例：
![](Pasted%20image%2020230318201715.png)
![](Pasted%20image%2020230318201903.png)
![](Pasted%20image%2020230318201914.png)

### DATA STORAGE MODELS

#### nsm 行存

![](Pasted%20image%2020230318202041.png)
之前都假设是nsm，行存。
![](Pasted%20image%2020230318202215.png)
一个tuple保存一条记录所有属性。
![](Pasted%20image%2020230318202258.png)
![](Pasted%20image%2020230318211241.png)
在做ap时，做了许多无用功。 不利于OLAP
![](Pasted%20image%2020230318211306.png)

#### dsm 列存 

DECOMPOSITION STORAGE MODEL

一个元组存一个属性（所有行的），利于olap
![](Pasted%20image%2020230318211849.png)
不同页存不同列

问题：如果去一行数据怎么办，怎么识别他是属于哪一行的（元组识别）
![](Pasted%20image%2020230318212028.png)
1. 不同的地方存不同行的。使用定长value
2. 加一个元素存id。

##### 优缺点

dsm优缺点：
![](Pasted%20image%2020230318212125.png)

## 总结

这两节课解决了磁盘上数据长什么样
![](Pasted%20image%2020230318212553.png)
接下来解决写入内存在重新写入磁盘
![](Pasted%20image%2020230318212606.png)