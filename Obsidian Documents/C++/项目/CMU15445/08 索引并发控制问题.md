
![](Pasted%20image%2020230321165033.png)
前面都是假设单线程
多线程安全访问问题。
为什么多线程？充分利用cpu核心，减少i/o阻塞的影响

redis是单线程，并行。

![](Pasted%20image%2020230321165425.png)
这节课主要目标是physical correctness：数据内部表示健壮

![](Pasted%20image%2020230322135055.png)
# latches overviem

![](Pasted%20image%2020230322135122.png)

![](Pasted%20image%2020230322135222.png)
lock用于事务并发
这节课研究latch

![](Pasted%20image%2020230322135259.png)
锁实现：
1. os的mutex互斥锁
![](Pasted%20image%2020230322135521.png)
加锁失败时os使其睡眠释放cpu，会有上下文切换的开销
![](Pasted%20image%2020230322135651.png)
2. 自旋锁
加锁失败会进行忙等待自旋，是个原子操作testandset。只能进行抢占式调度来抢占cpu。
![](Pasted%20image%2020230322140115.png)
3. 读写锁
实现依赖于自旋锁

# hash table latching

![](Pasted%20image%2020230322140129.png)
比较好加锁，线程都是同向移动获取数据，不会遇到死锁。
扩容时价格全局写锁

![](Pasted%20image%2020230322140330.png)
页由一组槽组成，一个槽对应一条数据库记录

![](Pasted%20image%2020230322144841.png)
自旋锁（原子）的底层实现，是个无锁操作
交给操作系统，先比较M是不是值V，如果是改成值V‘，不是的话直接返回失败。

# 3 b+树并发控制

![](Pasted%20image%2020230322144958.png)
并发问题
![](Pasted%20image%2020230322145157.png)
加锁思路：对每个结点进行加读写锁。
![](Pasted%20image%2020230322145210.png)
![](Pasted%20image%2020230322145323.png)

![](Pasted%20image%2020230322145832.png)
更新时每次都先锁上根节点
![](Pasted%20image%2020230322145854.png)
其实一般对一个叶子节点进行改变无法引起根节点的改变，先前的想法有些过于悲观了。
![](Pasted%20image%2020230322150030.png)
更新时叶节点加写锁，非叶节点加读锁。如果发现不止叶节点要修改，那么重新从根节点开始加写锁（回滚）。
![](Pasted%20image%2020230322150408.png)

叶节点扫描加锁
![](Pasted%20image%2020230322150755.png)
容易死锁
![](Pasted%20image%2020230322150836.png)
latch不支持死锁检测，因此要在编程时进行处理，比如只能从小往大走


![](Pasted%20image%2020230322151209.png)
