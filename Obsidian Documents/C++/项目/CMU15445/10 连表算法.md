**将join算子（单个运算）的执行方式**


为什么join
![](Pasted%20image%2020230324131030.png)
使用关系数据库表来避免了冗余
因此需要连表来重构原本的tuple避免信息损失

连接算法
==这节课研究内连接==
![](Pasted%20image%2020230324131246.png)

连表操作
![](Pasted%20image%2020230324131419.png)
1. 连表的输出是什么
2. cost评价指标

## output
![](Pasted%20image%2020230324131440.png)
取决于三方面：处理模型、存储模型、查询数据

![](Pasted%20image%2020230324132044.png)
早物化，全部数据都拿出来合并到一起

![](Pasted%20image%2020230324132116.png)
晚物化
将表的数据地址连接到一块。上级算子需要其他数据时需要回表

##  连表IO开销

![](Pasted%20image%2020230324132223.png)
开销模型，使用磁盘io开销

![](Pasted%20image%2020230324132341.png)
笛卡尔积中间结果很多，非常庞大
以下几种算法来减少开销，但是没一个表现好

# 连表算法

![](Pasted%20image%2020230324132448.png)

## 嵌套-循环连接（nested-loop join）

### 步骤

![](Pasted%20image%2020230324132736.png)
嵌套循环
小表指的是页数少的，需要磁盘io少

### 问题

也叫stupid nested loop join
为什么stupid？==没有利用缓存池==
![](Pasted%20image%2020230324132858.png)
cost是页数，每次换页都是一次io
![](Pasted%20image%2020230324133437.png)

### 优化

#### block nested loop join

内存中不能完全容纳一个关系。

![](Pasted%20image%2020230324133953.png)
把r的相同页的数据都进来，s的相同也数据都进来做nested loop操作
![](Pasted%20image%2020230324134102.png)
![](Pasted%20image%2020230324134231.png)

之前使用了缓存池中的两个页，但实际不止两张页。
![](Pasted%20image%2020230324134318.png)
![](Pasted%20image%2020230324134549.png)
![](Pasted%20image%2020230324135010.png)

![](Pasted%20image%2020230324135142.png)

#### index nested loop join

**内表使用索引**
![](Pasted%20image%2020230324135212.png)

### 总结

![](Pasted%20image%2020230324135326.png)

## sort-merge join

### 步骤

![](Pasted%20image%2020230324135549.png)
![](Pasted%20image%2020230324135834.png)

### 开销

![](Pasted%20image%2020230324144115.png)
#### 最坏情况
![](Pasted%20image%2020230324144156.png)
#### 最好情况：有序

![](Pasted%20image%2020230324144254.png)

## hash join

点查询快。

使用外表做hash table
![](Pasted%20image%2020230324144511.png)

### 算法步骤

1. 扫描外表根据连接属性，hash创建hash table
2. 扫描内表，使用hash函数定位hash table找到匹配的元组。

![](Pasted%20image%2020230324144521.png)
![](Pasted%20image%2020230324144622.png)
外表做哈希表
![](Pasted%20image%2020230324144641.png)
hash table的KV：
- key：连接列
- value：**早物化（整个tuple）和晚物化（RID/地址）两种**
![](Pasted%20image%2020230324144713.png)

### 优化


#### 布隆过滤器

防止内表匹配外边不存在的哈希。外表构建hash table的时候顺便构造bloom filter，内表查哈希表前先查布隆过滤器，有再去查hash table。
![](Pasted%20image%2020230324145624.png)
使用bloom filter。

### 问题

外表很大内存里存不下哈希表
![](Pasted%20image%2020230324150238.png)
将一部分放到磁盘上
- 解决算法：grace hash join
![](Pasted%20image%2020230324150403.png)
![](Pasted%20image%2020230324150523.png)
r表s表都用hash1做哈希，将同一个桶中的数据做nested loop join
此时假设整个哈希表无法存入内存，但是每一个桶可以存入内存。
如果一个桶页无法存入内存？继续使用hash2切割桶
![](Pasted%20image%2020230324150707.png)

### 开销

![](Pasted%20image%2020230324150955.png)
![](Pasted%20image%2020230324151044.png)
![](Pasted%20image%2020230324151545.png)




# 总结


![](Pasted%20image%2020230324151614.png)
![](Pasted%20image%2020230324151657.png)
