比较困难
![](Pasted%20image%2020230327221018.png)
sql语句是宣告式（命令时）的只要结果。
不同的计划器产生不同的计划
dbms优化器（optimizer）决定了具体怎么执行。
![](Pasted%20image%2020230327221138.png)
两条路：数据库做优化；人直接写执行计划

查询优化的两条路：
- 启发式/规则：重写。可能需要检查目录，但不需要检查数据
- 基于代价
![](Pasted%20image%2020230327221337.png)

![](Pasted%20image%2020230327222003.png)
优化器产生逻辑代数表达式到等效物理代数表达式的映射
![](Pasted%20image%2020230327222020.png)
逻辑计划：比如inner join（要执行什么查询）
物理计划：具体算子 比如hash join ，nested loop join（具体查询执行方式，什么方式完成查询）
- 物理算子定义里具体执行策略
  根据数据的物理形式

![](Pasted%20image%2020230327222142.png)
查询优化是个非多项式难问题

# 本节课内容

==这节课主要研究启发式查询优化==
![](Pasted%20image%2020230327222411.png)


# 等价关系表达式

![](Pasted%20image%2020230327222457.png)
结果相同即等价

谓词下推
![](Pasted%20image%2020230327222646.png)
![](Pasted%20image%2020230327222702.png)
选择：
- 先执行过滤
- 复杂谓词分解下推
![](Pasted%20image%2020230327222830.png)
连接：
- 交换连接顺序
- 穷举运算太慢
![](Pasted%20image%2020230327222838.png)
投影：
- 及早执行来产生更小的元组和减少中间结果(重复项被消除的话)
- 不需要的列属性消除
![](Pasted%20image%2020230327223120.png)
早物化晚物化方案
对列存数据库不重要，因为==列存都是晚物化==。

# 逻辑计划优化

![](Pasted%20image%2020230327223407.png)
使用模式匹配规则转化
没法比较新旧计划的好坏

![](Pasted%20image%2020230327234142.png)
![](Pasted%20image%2020230327234420.png)
![](Pasted%20image%2020230327234456.png)
![](Pasted%20image%2020230327234518.png)
![](Pasted%20image%2020230327234540.png)

# 嵌套子查询

![](Pasted%20image%2020230327234621.png)
![](Pasted%20image%2020230327234806.png)
解耦
![](Pasted%20image%2020230327234829.png)
直接算出子查询的数值来，不然每次会进行一次查询得到相同的数值。
![](Pasted%20image%2020230327234854.png)
先将子查询的结果算出来放到一个临时表中
![](Pasted%20image%2020230327235004.png)

# 表达式重写

![](Pasted%20image%2020230327235133.png)
![](Pasted%20image%2020230327235337.png)
以上三大块都是启发式优化

# 代价式查询优化

![](Pasted%20image%2020230327235551.png)

代价组成
![](Pasted%20image%2020230327235659.png)
![](Pasted%20image%2020230327235947.png)
![](Pasted%20image%2020230328000048.png)


![](Pasted%20image%2020230328000637.png)
代价式模型更先进