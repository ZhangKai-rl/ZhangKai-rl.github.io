**整个表达式执行的几种方式**

![](Pasted%20image%2020230325162923.png)
执行树

![](Pasted%20image%2020230325162945.png)

# 处理过程模型

![](Pasted%20image%2020230325163041.png)
定义了数据库系统的执行计划



## 迭代模型

也叫火山模型，pipeline
使用next和emit
![](Pasted%20image%2020230325163235.png)
每个算子实现了个next方法。父算子调用子算子的next来获取tuple

![](Pasted%20image%2020230325163401.png)
emit向上级算子返回，调用next时阻塞。
![](Pasted%20image%2020230325164655.png)
缺点：依靠函数调用来传输数据，当算子大时需要多次函数调用。

分为：需求驱动型流水线（从下向上执行）和生产则驱动型流水线

## 物化模型

使用一个数组来返回数据（存储中间结果、临时关系，需要写到磁盘）
![](Pasted%20image%2020230325170318.png)
没有流式（pipeline）的过程
![](Pasted%20image%2020230325172027.png)
一下全部完成在返回，每个算子只调用一次。
**就是比如说在最后的节点选择value>100，选择到大于100的==所有==元组，然后放到out里面（生成了临时关系），然后一起再往上执行。**
![](Pasted%20image%2020230325172127.png)
多用于TP数据库

### 代价及优化

代价分为两部分：运算代价和存储中间结果的代价。
优化：使用双缓冲，一块用于执行算法，另一块存储中甲结果不再写到磁盘。

还有个问题，一次性生成所有的中间结果可能需要等待很长时间（比如是个join操作）

## 向量化模型

两种模型的融合
![](Pasted%20image%2020230325172247.png)
![](Pasted%20image%2020230325172735.png)
每个out数组返回一批而不是全部
![](Pasted%20image%2020230325172506.png)


![](Pasted%20image%2020230325172800.png)

# ACCESS METHODS

![](Pasted%20image%2020230325174737.png)
读表，主要研究对表的读取

## sequential scan

![](Pasted%20image%2020230325174818.png)
优化方法：
![](Pasted%20image%2020230325174915.png)
bypass：不进缓存直接进执行器，用完直接扔

给每个页做个统计信息，dbms先检查这个zone map来判断是否需要读取这个页（从磁盘中读取）
![](Pasted%20image%2020230325175306.png)
问题：维护成本空间；zonemap存储位置，肯定不能存在这个页中
![](Pasted%20image%2020230325175402.png)
不往上传递数据本身，传递record id pk等
适用于列存，不适用于行存储

## index scan

![](Pasted%20image%2020230325175849.png)

## multi-index SCAN

![](Pasted%20image%2020230325175934.png)
两个索引并行进行
选取并集

# MODIFICATION QUERIES

对数据库有修改的查询
![](Pasted%20image%2020230325180105.png)
需要检查约束条件和维护索引

![](Pasted%20image%2020230325180753.png)
must keep track of previously seen tuples
比如说有个是999，那么可能被加两次

![](Pasted%20image%2020230325180839.png)

# 表达式计算

 ![](Pasted%20image%2020230325181027.png)
 DBMS使用表达式树来表示WHERE从句



![](Pasted%20image%2020230325181601.png)

