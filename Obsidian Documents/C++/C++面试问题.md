# C++基础

##### 函数调用栈变化

先将当前的PC压入本函数栈帧的栈顶作为返回地址（先压返回地址），然后压入当前函数的bp。为被调用函数开辟新栈帧，新栈帧的bp为调用函数栈帧的SP，将其压入调用函数的栈帧。将被调用函数的参数，局部变量压入新栈帧。被调用函数执行完后，SP = BP, bp= 之前压入的调用函数的BP。根据返回地址返回SP。
简单描述：先压返回地址，然后压函数参数，最后压函数中的变量
![](Pasted%20image%2020230604175118.png)


> C++11x新特性

1. 类型推导：decltype & auto
2. 左值右值
3. 列表初始化（包括返回值）
4. 模板改进
5. 并发
6. 智能指针
7. 基于范围的for循环
8. 委托构造函数、继承构造函数
9. nullptr & final & override & default & delete & explict

> struct和class区别，struct相对于C的变化

> 静态

	隐藏：static只能在本源文件中使用。只在声明时有static，定义处不加
	静态成员函数只能访问静态成员。
	static 作为关键字出现在C++语言当中,其修饰全局变量,局部变量,类成员变量,类成员函数等都有不同释义
	延长生命周期：修饰局部变量时，该变量的生命周期不受作用域限制。在执行到声明时会首次初始化，再次执行到声明不会再次初始化。如果没有显示初始化会被系统初始化为0.
返回值没有static，因此函数前面有static代表是个static函数。
静态成员函数属于类不属于对象因此没有this指针，因此只能访问静态变量


>SIGPIPE信号产生以及处理办法。


> 为什么要设置端口复用


> 为什么.h文件里需要#ifndef、#define和#endif？


> NULL和nullptr:


	NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针.

> const和#define的区别

	相同：两者定义的都是常量
	不同：
		- 编译器处理阶段不同
		- 类型和安全检查不同
		- 存储方式不同：define不分配内存。替换后会在内存中产生多份备份。const程序运行中只有一份备份。

>static的作用：
- 非类中
	 1.隐藏
	1. 延长生命周期
	2. 默认初始化0
- 类中
	- static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，**必须在类定义体外部初始化，初始化时不需要标示为static**；可以被非static成员函数任意访问。
	- static成员函数：无this，无法访问类对象的非static成员变量和非static成员函数；**不能被声明为const、虚函数和volatile**；可以被非static成员函数任意访问。

> const作用：
- 非类中：
	不可更改，隐藏。
- 类中：
	- const成员变量：必须有构造函数列表初始化。不能声明时初始化
	- const成员函数：const对象不能调用非const成员函数。不可以改变值。

>数组名和指向数组的指针和指向数组第一个元素的指针的区别？

>重写（override）和重载（overload）？

>拷贝初始化和直接初始化？值初始化和默认初始化？

>#define和inline

> 虚函数的意义

	当基类指针指向一个子类对象时，这个指针调用子类和基类同名成员函数的时候，基类声明为虚函数就会调用子类的函数，不声明就会调用自己的。
	实际例子：比如有个虚基类怪物，有个纯虚函数攻击。有三个派生类狼、蜘蛛、蛇，分别实现了自己不同的攻击函数。如狼是咬，蜘蛛吐丝，蟒蛇缠。出现很多怪物时可以定义一个虚基类指针数组，怪物指针数组，然后给他赋值不同的派生类对象指针，攻击时直接调用攻击函数即可使用不同类的攻击。
![](Pasted%20image%2020230304150931.png)

> insert push 和emplace的不同
	insert、push会进行拷贝初始化然后移动对象，emplace是直接初始化。
	emplace将参数传递给构造函数进行直接初始化，直接在容器尾部创建这个元素，不需要拷贝。
	push先创建这个元素，然后将这个元素拷贝或者移动到容器中。

> 拷贝构造函数和拷贝赋值运算符
	在初始化时使用等号调用拷贝构造函数进行初始化。定义完后，使用等号赋值时调用拷贝复制运算符。

> 内联函数

> 虚函数表

	当类中声明虚函数时，编译器会在类中生成一个虚函数表。虚函数表是一个存储成员函数地址的数据结构 
	虚函数表是由编译器自动生成与维护的。virtual成员函数地址会被编译器放入虚函数表中。存在虚函数表时，每个对象中都有一个指向虚函数表的指针。
	虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。
	虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。
	虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。
	为了指定对象的虚表，每个对象的内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。
![](Pasted%20image%2020230304173402.png)


> 多态

	多态指当不同的对象收到相同的消息时，产生不同的动作
	
	-   编译时多态（静态绑定），函数重载，运算符重载，模板。
	-   运行时多态（动态绑定），虚函数机制。

	C++多态实现的原理：
	
> 	-    当类中声明虚函数时，编译器会在类中生成一个虚函数表
> 	-   虚函数表是一个存储成员函数地址的数据结构
> 	-   虚函数表是由编译器自动生成与维护的
> 	-    virtual成员函数会被编译器放入虚函数表中
> 	-   存在虚函数表时，每个对象中都有一个指向虚函数表的指针

> public和private继承

>  ![](Pasted%20image%2020230304213836.png)


> const
> 常成员函数------const位于函数体前面
> 	只能调用常成员函数
> 	常对象只能调用常成员函数
> 	可以被任意成员函数调用
> 	实现和声明都加const
> 	可用于重载


> 初始化列表
> 必须使用的情况：常量成员、引用成员、没有默认构造函数（避免了一次默认构造过程，因此类类型成员最好使用初始化列表）
> 按照成员声明顺序初始化

> struct和class区别：
	默认权限不同：继承和成员默认权限不同
	主要是为了对c兼容，主要是定义一个数据结构。

>左值引用、右值引用、移动语义、完美转发？

>extern C 的作用?

主要是为了兼容C语言代码。会指示编译器这部分代码按照C语言进行编译。

>模板类内部能不能有虚函数

>函数调用时的压栈情况

- 调用函数将被调函数参数从右向左压栈，再将call指令下条指令地址压栈。
- 被调函数先压栈调用者函数栈底地址，在压栈当前函数栈底地址。
- 被调函数压栈局部变量

# C++内存

##### 内存对齐

结构体占用的内存空间是连续的。
什么叫非内存对齐：从一个地址（起始地址）开始读取N字节数据，但是该地址不能被N整除（即`addr % N != 0`）时，就会发生非对齐内存访问。
内存对齐规则：
- 第一个成员在结构体地址起始处
- 其他成员要对齐到对齐数倍数地址处。**对齐数= 编译器默认对齐数与该成员大小的较小值**

##### 内存分区

从下往上分别是：.text, .rodata, .data/.bss, heap, map, stack.
虚函数表放在.rodata区

# STL

>什么是STL?

包括三类：算法、容器、迭代器。

>增加删除元素导致迭代器失效问题
>![](Pasted%20image%2020230426135811.png)

## VECTOR

> vector内存增长（capacity和size）



# 设计模式

## 单例模式

>为什么instance和getInstace是静态的？
 1. getInstance函数是静态的，没有this指针。如果instance不是静态的则无法调用
 2. instance需要在调用getInstance时初始化，只有静态成员才可以在没有对象的情况下初始化，而且初始化后就不会再次初始化，保证了单例。
 3. 没法创建类对象，因此必须把getInstace设为静态类变量，从而可以不创建对象来调用
## 实现

### 懒汉

懒汉不是线程安全的

1. 加锁指针单例对象
```c++
class Singleton {
private :
	static Singleton* instance;
private :
	Singleton();
	~Singleton(); // 此时析构成了私有，因此存在内存泄漏问题
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
public :
	static Singleton* getInstance() {
		//双检测锁模式
		if (instance == nullptr) {
			Lock lock;
			if (instance == nullptr) {
				instance = new Singleton();
			}
		}
		return instanc;
	}
	static void deleteInstance();
};
```
2. 局部懒汉(最优雅实现，项目中用的这个)
```c++
class Singleton{
private :
	Singleton();
	~Singleton();
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
public :
	static Singleton& getInstace() {
		static Singleton instance;
		return instance;
	}
};
```

### 饿汉

```c++
class Singleton {
private :
	Singleton();
	~Singleton();
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
private :
	static Singleton instance;
public :
	static Singleton& getInstance() {
		return instance;
	}
};
Singleton Singleton::instance; 
```
# 笔试

## sizeof

1. sizeof得到的是字节数，sizeof数组名得到数组总共的字节数，sizeof指针（动态数组）得到的是指针大小（32位为4Byte，64位为8Byte）