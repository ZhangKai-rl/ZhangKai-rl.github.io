# 参考笔记

[MIT6.824网课学习笔记-01 (ashiamd.github.io)](https://ashiamd.github.io/docsify-notes/#/study/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AD%96%E7%95%A5/MIT6.824%E7%BD%91%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01?id=lecture11-%e9%93%be%e5%bc%8f%e5%a4%8d%e5%88%b6chain-replication)
[Lecture 09 - More Replication, CRAQ - MIT6.824 (gitbook.io)](https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-09-more-replication-craq)




一些分布式的问题:
- ==性能==
- ==容错==
- 物理
- 安全/隔离
挑战：
- 并发
- 局部错误
- 性能


三部分基础设施：存储，通信，计算。需要抽象模型
更关注于存储。

# 主题

## 实现

- RPC
- threads
- 并发

## 性能

可扩展性(scalability)： 2×计算资源->2×吞吐量

## 容错

可用性：建立在特定类型的错误上
可恢复性

### 容错工具

非易失性存储
复制/副本

## 一致性

强一致性：get得到最新的put版本
弱一致性：可能get到旧值

# MapReduce

分布式并行计算。两个操作：map and reduce

## 模型

![](Pasted%20image%2020230716001012.png)

## 步骤

**MapReduce 的工作流：**

- 将输入文件分成 M 个小文件（每个文件的大小大概 16M-64M），在集群中启动 MapReduce 实例，其中一个 Master 和多个 Worker；
- 由 Master 分配任务，将 `Map` 任务分配给可用的 Worker；
- `Map` Worker 读取文件，执行用户自定义的 map 函数，输出 key/value 对，缓存在内存中；
- 内存中的 (key, value) 对通过 `partitioning function()` 例如 `hash(key) mod R` 分为 R 个 regions，然后写入磁盘。完成之后，把这些文件的地址回传给 Master，然后 Master 把这些位置传给 `Reduce` Worker；
- `Reduce` Worker 收到数据存储位置信息后，使用 RPC 从 `Map` Worker 所在的磁盘读取这些数据，根据 key 进行排序，并将同一 key 的所有数据分组聚合在一起（**由于许多不同的 key 值会映射到相同的 Reduce 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序**）；（shuffle）
- `Reduce` Worker 将分组后的值传给用户自定义的 reduce 函数，输出追加到所属分区的输出文件中；
- 当所有的 Map 任务和 Reduce 任务都完成后，Master 向用户程序返回结果；