# 概览

## 预习

读教材：# [Principles Of Computer System Design: An Introduction](https://ocw.mit.edu/courses/res-6-004-principles-of-computer-system-design-an-introduction-spring-2009/)
谈论事务的概念，不涉及具体的分布式事务系统的涉及。为下两篇论文做准备。

## 主题

- 2PL
- 2PC
- 3PC

# 事务原语

使用事务目的：关注事务是因为想要进行跨机器的原子操作。在故障和并发方面保持原子性。

原语：使用数据库事务原语即可保证原子执行，无需自己设置锁，也会故障自动恢复

- begin
- commit
- abort：除了认为调用，事务本身遇到死锁也会自动abort

# ACID

事务的四个关键属性：

- atomic原子性：要么全部执行，要么全部没有执行。比如崩溃时
- consistency一致性：数据库有内部变量，如参照完整性（外码），事务要保证这种内部的一致性
- isolation隔离性：两个事务，不会观察到彼此的中间结果。好像只有自己在运行一样。
- durability持久性：结果写入稳定存储。即使崩溃后恢复，也应该存在

主要讲A(崩溃及恢复)和I（保证隔离性的方法）。

# 隔离性

==可串行化：多个事务并行执行和以某种顺序串行执行结果相同。==
冲突可串行化：交换相邻的非冲突操作后和某个串行执行顺序相同。

**如有两个事务T1, T2那么串行化调度有两个：T1->T2; T2->T1可能有两种串行调度的结果。进行冲突等效，如果结果等于串行化调度中的一种，那么他就是可串行化的。**

非常类似于之前的线性一致性，两者的关键区别是：**在线性一致性中，如果T2在T1结束后开始，那么T2在整体顺序中必须出现在T1之后；而可串行化中无此要求，即使T2开始时间晚于T1的结束时间，系统仍然允许对T1和T2重排序使得T2在T1之前**。所以可串行化在执行顺序的要求上比可线性化要求弱一些。

## 禁止场景

|T1|T2|
|---|---|
||get(X)|
|Transfer(X,Y) 对X、Y进行修改||
||get(Y)|

|T1|T2|
|---|---|
|put(X)||
||get(X)|
||get(Y)|
|put(Y)||
这两种场景冲突等效后都无法可串行化，数据库应禁止这种调度的发生。

**两种方法来禁止这些行为：并发控制和2PL**

## 并发控制

有两种：
- 悲观：使用锁。只有确保能够串行化执行后才会释放锁。
- 乐观：不使用锁，在提交点时，统一确认之前的一系列操作是否符合可串行化的要求，如果符合则正常执行。**如果不符合，则被abort**。这里可能会引入一些重试机制。

在后续课程中会讨论**乐观锁的实现--FaRM.(乐观的分布式事务系统实现)**
今天注重于悲观方式。

## 2PL

并发控制中悲观锁的实现方式之一。

实现可串行化隔离级别的一种方式。
lock per record。
两条规则：

- 事务开始之前需要锁
- 事务拥有锁之后，只能在commit/abort时释放锁（可串行化要使用严格两阶段锁）

​ **2PL是对文档中简单锁(严格锁)的改进**。

- **简单锁(simple locking)或严格锁(strict locking)，在事务开始前，你获取整个事务所需的所有锁，持有这些锁直到提交点进行commit或者abort，然后释放所有锁。**
- **==2PL的锁更细粒度一点==（因而会有更高的并发度），不需要在事务开始前直接获取所有锁，相反的，在事务运行时动态增量的获取锁，支持某些严格锁(简单锁)不允许的并发模式**。

第二条规则：如果不遵守，事务的中间结果可能被其他事务看见。

### 死锁

持有并等待。
事务系统有abort操作。
如果事务系统可以检测到死锁(deadlock)，对任意一个事务执行abort操作，使其中一个事务能正常获取lock完成事务，并中止另一个事务。而客户端client或应用程序可以自己决定如何处理事务被abort的情况，比如事务重试或放弃执行等等，但至少避免了死锁。（有一种乐观锁的感觉）

#### 检测方法

两种：
- 基于超时：几个事务运行很长时间没有进展，那么中止其中一个。
- 等待图（wai-for graph）：如果有环则表示死锁

中止后会释放所有锁。客户端得到通知可以选择重新运行。

# 讨论

问题：举例严格锁（简单锁）不如严格二阶段锁并发性更高的场景。

     _比如事务中读取的某个变量极小概率会是true，而变量为true时，才会执行后序事务逻辑，那么这里不需要在事务开始前就加锁，可以等读到变量时再加锁。_

# 原子性

## 2PC--崩溃恢复

解决问题：跨机器事务的原子性。
Spanner、TiDB都是用2PC

事务系统中接受事务的机器称为**协调器**（有可能是一个事务服务器承担这个角色），协调器负责通过事务系统运行事务。
协调器管理多个事务服务器。

分片，而不是复制情况（复制的是raft，基于大多数原则）。

|时序|coordinator(协调器)|A服务器拥有X记录|B服务器拥有Y记录|
|---|---|---|---|
|1|新建事务(tid)，**这是有个事务，但是需要多个事务服务器参与**。告知A执行put(X), 告知B执行put(Y)|||
|2||Lock X（2PL）, put(X), log X(日志记录)。这里暂时没有实际操作数据库，**只是log记录**|log Y(日志记录), Lock Y, log Y(日志记录)，这里暂时没有实际操作数据库，只是log记录|
|**第一阶段prepare（是否写好了日志，准备好执行事务了吗？）**||
|3|对A、B发起prepare询问请求（包括tid），询问A和B是否正常log了事务需要的操作|||
|4||A查看自己的状态，发现持有X的锁，并且log了需要执行的put操作，如果准备好了提交回应prepare请求YES|B查看自己的状态，发现持有Y的锁，并且log了需要执行的put操作，回应prepare请求YES|
|**收到所有服务器的YES后进入第二阶段：commit。进行日志物化。==之后服务器不能单方面终止==**||
|5|收到A和B的prepare响应YES后，得知A和B可以准备提交事务了，向A和B发起commit(tid)请求|||
|6||A看本地log，发现tid对应的事务可以提交了，于是install日志（物化操作），即执行日志中记录的put(X)操作，然后释放X的锁，对commit请求响应OK|B看本地log，发现tid对应的事务可以提交了，于是install日志，即执行日志中记录的put(Y)操作，然后释放Y的锁，对commit请求响应OK|
|7|收到A和B的OK，知道A和B都成功执行完事务了|
都同意才能提交。
第一个阶段一定是prepare，第二个阶段可能是commit/abort

## 2PC崩溃场景分析

1. 参与事务的服务器在prepare阶段回复了yes，但是之后崩溃了。
	- **既然在prepare阶段回复了yes，那么他必须执行这个事务**。当他恢复后必须进行执行事务。因此需要将参与事务的tid，持有的锁的**持久化**到稳定存储，恢复后继续走流程。（因而代价比较昂贵）
2. **coordinator在发送commit（tid）之后崩溃（时序5之后）。**
	- 进入第二阶段后事务服务器不再可以单方面终止。只能等待协调器恢复，此时事务服务器持续持有锁。
	- ​ 类似事务参与者，协调者在发送commit(tid)请求之前，需要记录log、tid（到稳定存储），崩溃后根据log继续执行事务流程。这里假设协调者崩溃前，A回应了OK，但是B回应协调者之前，协调者崩溃了。那么B必须等待协调者恢复后，再回应协调者OK，而不能私自中止事务。
		 这种情况下，B很不幸必须一直等待，这里其他事务如果要占用Y数据的锁就会失败，因为B需要等待协调者恢复后，能响应协调者时再释放锁。
3. 事务服务器没有回应coordinator的prepare请求。
	- 会有超时时间。coordinator可以单方面中止

## 2PC容错分析

**第二种崩溃场景为单点故障**，我们可以使用之前学过的课程内容来解决着种严重问题。
通过raft和RSM来实现协调者复制，从而使协调者具有容错性。（lab4 内容）
raft保持复制的状态机实现协调者副本同步。

# 课后答疑

> ==raft和2PC的关系==

- 原则：**最大的区别就是Raft基于majority原则；而2PC要求所有机器都有一致的回应**。
- 用途：raft是用于复制，所有服务器做相同的事情，用于实现RSM；而2PC所有参与的事务服务器操作不同的数据（分片）。
- **raft用于实现高可用性（复制）；2PC用于实现跨机器的原子操作**（跨机器事务要么全部成功，要么全部失败）。
- 是为不同的目的设计的（2PC是为了参与者（参与者不在一台机器）达成一致协议）。可以使用raft来让2PC的coordinator具有容错性或者参与者有更高的可用性

# 2PL、2PC变体

